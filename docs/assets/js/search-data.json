{"0": {
    "doc": "Home",
    "title": "Sections",
    "content": "| section | location | time | . | Section A | Howe 102 | MWF 10:00am - 10:50am | . | Section B | Howe 102 | MWF 11:00am - 11:50am | . | Section C | McLean 114 | MWF 1:00pm - 1:50pm | . ",
    "url": "/",
    
    "relUrl": "/"
  },"1": {
    "doc": "Home",
    "title": "Schedule",
    "content": "Goto Current Week | wk | date | # | lecture | reminders | notes | recording | assignments | . | 1 | 01/21 | 1 | syllabus, intro | | lec1 (template) | zoom | pa1 (due 1/30) | . | 01/23 | 2 | os history | | lec2 (template) | zoom | . | 2 | 01/26 | 3 | os concepts and structure | | lec3 (template) | zoom | . | 01/28 | 4 | hardware review | | lec4 (template) | zoom | . | 01/30 | 5 | intro to linux pt1 | | lec5 (template) | zoom | . | 3 | 02/02 | 6 | intro to linux pt2 | | lec6 (template) | zoom | pa2 (due 2/27) | . | 02/04 | 7 | syscalls | | lec7 (template) | zoom | . | 02/06 | 8 | processes | quiz | | | . | 4 | 02/09 | 9 | processes | | | | . | 02/11 | 10 | processes | | | | . | 02/13 | 11 | processes | | | | . | 5 | 02/16 | - | holiday (presidentâ€™s day) | | | | . | 02/18 | 12 | linux processes | | | | . | 02/20 | 13 | threads | | | | . | 6 | 02/23 | 14 | threads | | | | . | 02/25 | 15 | threads | | | | . | 02/27 | 16 | scheduling | quiz | | | . | 7 | 03/02 | 17 | scheduling | | | | pa3 (due 3/13) | . | 03/04 | 18 | scheduling | | | | . | 03/06 | 19 | scheduling | | | | . | 8 | 03/09 | 20 | concurrency | | | | . | 03/11 | 21 | concurrency | | | | . | 03/13 | 22 | midterm | midterm | | | . | 9 | 03/16 | - | spring break | | | | pa4 (due 4/3) | . | 03/18 | - | spring break | | | | . | 03/20 | - | spring break | | | | . | 10 | 03/23 | 23 | midterm review | | | | . | 03/25 | 24 | concurrency | | | | . | 03/27 | 25 | concurrency | | | | . | 11 | 03/30 | 26 | concurrency | | | | . | 04/01 | 27 | synchronization | | | | . | 04/03 | - | holiday (good friday) | | | | . | 12 | 04/06 | 28 | memory management | | | | pa5 (due 4/17) | . | 04/08 | 29 | memory management | | | | . | 04/10 | 30 | virtual memory | quiz | | | . | 13 | 04/13 | 31 | page replacement | | | | . | 04/15 | 32 | page replacement | | | | . | 04/17 | 33 | page replacement | | | | . | 14 | 04/20 | 34 | page replacement | | | | project (due 5/6) | . | 04/22 | 35 | file systems | | | | . | 04/24 | 36 | file systems | quiz | | | . | 15 | 04/27 | 37 | io | | | | . | 04/29 | 38 | io | | | | . | 05/01 | 39 | disks | | | | . | 16 | 05/04 | 40 | disks | | | | . | 05/06 | 41 | disks | | | | . | 05/08 | - | finals | | | | | . | 17 | 5/11 - 5/16 | - | finals | | | | . ",
    "url": "/",
    
    "relUrl": "/"
  },"2": {
    "doc": "Home",
    "title": "Home",
    "content": ". Welcome to CS 492! . ",
    "url": "/",
    
    "relUrl": "/"
  },"3": {
    "doc": "Assignments",
    "title": "Assignments",
    "content": " ",
    "url": "/assignments/",
    
    "relUrl": "/assignments/"
  },"4": {
    "doc": "Lectures",
    "title": "Lectures",
    "content": " ",
    "url": "/lectures/",
    
    "relUrl": "/lectures/"
  },"5": {
    "doc": "Lecture 1 Annotated",
    "title": "Lecture 1 Annotated",
    "content": ". . . 01 - Intro to Operating SystemsOutlineReading: MOS 1.1What is an OS?1)2)3)4)Where does the OS fit in?Short answer:A software abstraction layer and resource manager.First, what does the OS fit into?Let's look at a relatively simple computer.A Raspberry Pi.Usually you use multiple applications or programsrunning in a User Interface (UI).It would be prohibitively difficult for applicationsto manage hardware directly: - domain knowledge - resource contention - trustThe operating system provides an API thatprograms can use to access hardware capabilitieswithout needing to manage hardware componentsdirectly.We've already identified 2: &gt; Abstraction of hardware (extended machine) - Ex: file systems to access disk memory - Hide the ugly from application programmers &gt; Management of hardware (resource manager) - Enable concurrency/parallelism - Memory + I/O management/protection - Multiplex (share) resources in time and spaceAdditionally: &gt; Security - Enforce access control - Process isolationIt's not the UI alone. This course focuses on the kernel.System Stack:Even though it so small, there's a lot going on.We need to take all this hardware and turn it intosomething useable.Every component requires non-trivial code to bemanaged correctly.- Dedicated hardware controllers help, butaren't a replacement.And that's peanuts compared to a full mainboard.This one is from ~2005.Now they look all space-y.Some examples you may be familiar with:- Windows- macOS- Linux - Debian - Ubuntu - Arch Linux - Android - Kali Linux - too many...Some examples you may not be familiar with:- Minix- Multics- OpenSolaris - illumos- BSD - FreeBSD - OpenBSD - NetBSD- VxWorks- ZephyrOS- FreeRTOS- QNXWhat are its main functions?What is considered an OS?What is an OS?Where does the OS fit in? . . . . GPIO, SPI, I2C, UART, SDA, PWM, ...USBDSI DisplayCSI CameraAudioHDMIPowerBCM 2835SoCEthernetController . . Text UI (TUI)Graphical UI (GUI) . User Interface . Browser . Terminal . Editor . Operating System . Hardware . Software . . . . . MOS Figure 1-1What are its main functions?What is considered an OS?UIs . . Raspi 3 Diagramasrock k7vt4a pro mainboardgigabyte x570 elite mainboard . Hardware . Application . Hypervisor/VM monitor . Core Runtime Libraries . User Interface . Compiler . Runtime Libraries . Kernel . KernelExtension . KernelExtensionOSSystemSoftwareKernel Mode(privileged)User Mode(unprivileged) . . . system stack . . ",
    "url": "/lectures/lec01-annotated.html",
    
    "relUrl": "/lectures/lec01-annotated.html"
  },"6": {
    "doc": "Lecture 1 Template",
    "title": "Lecture 1 Template",
    "content": ". . . 01 - Intro to Operating SystemsOutlineReading: MOS 1.1What is an OS?1)2)3)4)Where does the OS fit in?Short answer:A software abstraction layer and resource manager.First, what does the OS fit into?Let's look at a relatively simple computer.A Raspberry Pi.Usually you use multiple applications or programsrunning in a User Interface (UI).It would be prohibitively difficult for applicationsto manage hardware directly: - domain knowledge - resource contention - trustThe operating system provides an API thatprograms can use to access hardware capabilitieswithout needing to manage hardware componentsdirectly.We've already identified 2: &gt; Abstraction of hardware (extended machine) - Ex: file systems to access disk memory - Hide the ugly from application programmers &gt; Management of hardware (resource manager) - Enable concurrency/parallelism - Memory + I/O management/protection - Multiplex (share) resources in time and spaceAdditionally: &gt; Security - Enforce access control - Process isolationIt's not the UI alone. This course focuses on the kernel.System Stack:Even though it so small, there's a lot going on.We need to take all this hardware and turn it intosomething useable.Every component requires non-trivial code to bemanaged correctly.- Dedicated hardware controllers help, butaren't a replacement.And that's peanuts compared to a full mainboard.This one is from ~2005.Now they look all space-y.Some examples you may be familiar with:- Windows- macOS- Linux - Debian - Ubuntu - Arch Linux - Android - Kali Linux - too many...Some examples you may not be familiar with:- Minix- Multics- OpenSolaris - illumos- BSD - FreeBSD - OpenBSD - NetBSD- VxWorks- ZephyrOS- FreeRTOS- QNXWhat are its main functions?What is considered an OS?What is an OS?Where does the OS fit in? . . . . GPIO, SPI, I2C, UART, SDA, PWM, ...USBDSI DisplayCSI CameraAudioHDMIPowerBCM 2835SoCEthernetController . . Text UI (TUI)Graphical UI (GUI) . User Interface . Browser . Terminal . Editor . Operating System . Hardware . Software . . . . . MOS Figure 1-1What are its main functions?What is considered an OS?UIsRaspi 3 Diagramasrock k7vt4a pro mainboardgigabyte x570 elite mainboard . Hardware . Application . Hypervisor/VM monitor . Core Runtime Libraries . User Interface . Compiler . Runtime Libraries . Kernel . KernelExtension . KernelExtensionOSSystemSoftwareKernel Mode(privileged)User Mode(unprivileged) . . . system stack . ",
    "url": "/lectures/lec01-template.html",
    
    "relUrl": "/lectures/lec01-template.html"
  },"7": {
    "doc": "Lecture 2 Annotated",
    "title": "Lecture 2 Annotated",
    "content": ". 02 - History of Operating SystemsOutlineTimelineEarly Days (Before OSes)Transistors &amp; Batch SystemsAnnouncementsReading: MOS 1.2Discord is up: https://discord.gg/SNfKFK8bZQpa1 is up on gradescope.You need to add a role to not be kicked.Email with \"CS 492\" somewhere in the subject line.I'm much more likely to see it if you do.1940 - 1955: Early Days1965 - 1980: ICs &amp; Multiprogramming1955 - 1965: Transistors &amp; Batch Systems1980 - Present: PCs1)2)3)4)5)Other Operating Systems . . . . . . . 1942194319451953195419561957195919601961196419661969196819811982197819831984198519871991199219931994199519961974197319711958 . Colossus Mark 1 - First programmable, electronic, digital - Tommy Flowers @ Bletchley Park - WWII code-breaking . Manchester Transistor Computer - First transistor computer - Richard Grimsdale + D.C. Webb - 92 point-contact transistors . GM-NAA I/O System - First Operating System for IBM 704 - Robert L. Patrick (General Motors) &amp; Owen Mock (NA Aviation) - Batch processing: automatically execute a new program after the previous program finishes. ENIAC - First programmable, electronic, digital, general-purpose (Turing-complete) - John Mauchly + J. Presper Eckert - Compute ballistics trajectories - Original Programmers: Betty Holberton, Kay McNulty, Marlyn Wescoff, Ruch Lichterman, Betty Jean Jennings, Fran Bilas19441941 . Atanasoff-Berry computer (ABC) - First electronic, digital - John Atanasoff + Clifford Berry @ Iowa State University - 300+ vacuum tubes . Harvard Mark I - General-purpose electromechanical - Howard Aiken - Used by von John von Neumann during the Manhattan Project . Z3 - First programmable, digital - Konrad Zuse - 2600 electromechanical relays - 22-bit words, 5-10 HzMarlyn Wescoff (left), Ruth LictermanENIAC Programmers . UMES - Bernard Galler @ UMich - Adapted for students . BESYS (Bell Labs) . SHARE Operating System . IBM 1401 &amp; IBM 7090 released - Popular Transistor Mainframes . IBM System/360 - Both commercial and scientific applications - Family of (mostly) software-compatible mainframes - First major line to use hybrid ICs - Released with DOS/360 . Multics (began 1964) - Designed by MIT, Bell Labs, GE - Support 100s of timesharing users (Everyone logs into one big machine) - Seminal Ideas: - Hierarchical file system, Shell - Segments, Paging, Virtual Memory - Dynamic Linking - Security (Ring-based Access Control) - Commercial flop: - 5 years to ship - PL/I language (compiler late) - Very ambitious/complex . UNIX manual published (began 1969) - Ken Thompson, Dennis Ritchie @ Bell Labs (Multics developers) - Originally proprietary - Initially designed as single-user version of Multics - Written in assembly, later C - Inherited shell and hierarchical file system from Multics - \"UNIX philosophy\" modular design - Very popular: - Cheap to access source - Ran on cheap hardware - Easily portable . OS/360 - First OS for many computers - Compatibility -&gt; commercial success - Large, complex, many problems - Popularized multiprogramming - Introduced spooling . IBSYS (IBM) . MIT CTSS - Compatible Time-Sharing System (concurrency) - First timesharing OSJack Kilby @ Texas Instrumentsinvents the integrated circuit (IC) . IBM 704 - First mass-produced mainframe with floating point hardware - John Backus &amp; Gene Amdahl - Fun Facts: - FORTRAN &amp; LISP written for it - Mean time to failure 8 hoursIBM 704 at NACA, 1957Batch Systems . MOS Figure 1-3ICs &amp; Multiprogramming . . Multiprogramming meantto minimize idle CPUtime due to I/OoperationsMain memory partitions allow CPU to switch betweenjobs while a another waits for I/O operations.Requires hardware to prevent read across partitions.Large Scale Integration (LSI) fits 1000xtransistors in a square cm.Computers get small enough and cheap enoughthat it's practical for individuals to ownmicrocomputers, later called personal computers.Spooling (Simultaneous PeripheralOperation On Line) automaticallyqueued jobs to be loaded insteadof waiting until completion.Personal Computers . Intel 8080 - 8080 first general-purpose 8-bit CPU - Used in first microcpu with a disk . Xerox Alto (Xerox PARC) - GUI, mouse, Ethernet, WYSIWYG editor . oN Line System (NLS) - Doug Engelbert @ SRI Intl. - \"The Mother of All Demos\" - Windows, hypertext, graphics, mouse, word processing, VCS, collaborative real-time editing . CP/M - CP/M disk-based OS, written for a 8-inch 64kB memory floppy disk - Gary Kildall -&gt; Digital Research - Rewritten 1977 for more CPUs - Dominated microcomputing until 1982 - Introduced the BIOS . MS-DOS (86-DOS) - Released for IBM PC - A clone of CP/M by Tim Paterson for Intel 8086 - Acquired by Microsoft for ~$75k - Supplants CP/M after a year more commands, FAT file system . Berkeley Software Distribution (1BSD) - Bill Joy @ UC Berkeley CSRG - Originally added virtual memory to AT&amp;T Unix - Permissive licensing made it very popular (FOSS) - Later versions would introduce networking stack - vi text editor in 2BSD (1979) . Apple Lisa (Lisa OS) - First mass-market PC operable via GUI - Inspired by Xerox PARC GUI . UNIX System V (AT&amp;T) . Apple Macintosh 128K (macOS) - First successful mass-market all-in-one GUI PC - Built-in screen and mouse . Windows 1.0 (not an OS) - Microsoft's first GUI for MS-DOS - Calculator, Clock, Notepad, Control Panel, Paint, etc. MINIX - Andrew S. Tanenbaum @ VU Amsterdam - Educational UNIX clone - Microkernel architecture . Linux kernel - Linus Torvalds for x86 PCs - Free and Open-Source Software (FOSS) - Immediately saw variantsIntel 8080MS-DOS promptMacintosh 128K . FreeBSD . Solaris (from SunOS) . OpenBSD . Red Hat . OpenSUSE . Windows CE . NetBSD . Slackware . Debian . VxWorks . QNXOS landscape gets dominated by Microsoft, Apple, andLinux...Mobile Operating SystemsReal-Time Operating SystemsMiscellaneousOperating systems evolve alongside hardwareadvances and UI paradigms.People like free software.Examples:QNXZephyrfreeRTOSNuttXToaruOSTempleOSSerenityOSTockChibiOS/RTVxWorksThreadXApplications with time-critical constraints - can be soft or hard real-time - fast, deterministic response timesDesigns can be: - Event-driven (preemptive) - Time-sharing (round-robin)Often run in embedded systems1997 - Symbian1999 - Blackberry OS2007 - iOS2008 - Android2009 - Windows Phone2019 - HarmonyOS2021 - FuchsiaMobile ComputingOther Operating SystemsTakeaways1)2) . ",
    "url": "/lectures/lec02-annotated.html",
    
    "relUrl": "/lectures/lec02-annotated.html"
  },"8": {
    "doc": "Lecture 2 Template",
    "title": "Lecture 2 Template",
    "content": ". 02 - History of Operating SystemsOutlineTimelineEarly Days (Before OSes)Transistors &amp; Batch SystemsAnnouncementsReading: MOS 1.2Discord is up: https://discord.gg/SNfKFK8bZQpa1 is up on gradescope.You need to add a role to not be kicked.Email with \"CS 492\" somewhere in the subject line.I'm much more likely to see it if you do.1940 - 1955: Early Days1965 - 1980: ICs &amp; Multiprogramming1955 - 1965: Transistors &amp; Batch Systems1980 - Present: PCs1)2)3)4)5)Other Operating Systems . . . . . . . 1942194319451953195419561957195919601961196419661969196819811982197819831984198519871991199219931994199519961974197319711958 . Colossus Mark 1 - First programmable, electronic, digital - Tommy Flowers @ Bletchley Park - WWII code-breaking . Manchester Transistor Computer - First transistor computer - Richard Grimsdale + D.C. Webb - 92 point-contact transistors . GM-NAA I/O System - First Operating System for IBM 704 - Robert L. Patrick (General Motors) &amp; Owen Mock (NA Aviation) - Batch processing: automatically execute a new program after the previous program finishes. ENIAC - First programmable, electronic, digital, general-purpose (Turing-complete) - John Mauchly + J. Presper Eckert - Compute ballistics trajectories - Original Programmers: Betty Holberton, Kay McNulty, Marlyn Wescoff, Ruch Lichterman, Betty Jean Jennings, Fran Bilas19441941 . Atanasoff-Berry computer (ABC) - First electronic, digital - John Atanasoff + Clifford Berry @ Iowa State University - 300+ vacuum tubes . Harvard Mark I - General-purpose electromechanical - Howard Aiken - Used by von John von Neumann during the Manhattan Project . Z3 - First programmable, digital - Konrad Zuse - 2600 electromechanical relays - 22-bit words, 5-10 HzMarlyn Wescoff (left), Ruth LictermanENIAC Programmers . UMES - Bernard Galler @ UMich - Adapted for students . BESYS (Bell Labs) . SHARE Operating System . IBM 1401 &amp; IBM 7090 released - Popular Transistor Mainframes . IBM System/360 - Both commercial and scientific applications - Family of (mostly) software-compatible mainframes - First major line to use hybrid ICs - Released with DOS/360 . Multics (began 1964) - Designed by MIT, Bell Labs, GE - Support 100s of timesharing users (Everyone logs into one big machine) - Seminal Ideas: - Hierarchical file system, Shell - Segments, Paging, Virtual Memory - Dynamic Linking - Security (Ring-based Access Control) - Commercial flop: - 5 years to ship - PL/I language (compiler late) - Very ambitious/complex . UNIX manual published (began 1969) - Ken Thompson, Dennis Ritchie @ Bell Labs (Multics developers) - Originally proprietary - Initially designed as single-user version of Multics - Written in assembly, later C - Inherited shell and hierarchical file system from Multics - \"UNIX philosophy\" modular design - Very popular: - Cheap to access source - Ran on cheap hardware - Easily portable . OS/360 - First OS for many computers - Compatibility -&gt; commercial success - Large, complex, many problems - Popularized multiprogramming - Introduced spooling . IBSYS (IBM) . MIT CTSS - Compatible Time-Sharing System (concurrency) - First timesharing OSJack Kilby @ Texas Instrumentsinvents the integrated circuit (IC) . IBM 704 - First mass-produced mainframe with floating point hardware - John Backus &amp; Gene Amdahl - Fun Facts: - FORTRAN &amp; LISP written for it - Mean time to failure 8 hoursIBM 704 at NACA, 1957Batch Systems . MOS Figure 1-3ICs &amp; Multiprogramming . . Multiprogramming meantto minimize idle CPUtime due to I/OoperationsMain memory partitions allow CPU to switch betweenjobs while a another waits for I/O operations.Requires hardware to prevent read across partitions.Large Scale Integration (LSI) fits 1000xtransistors in a square cm.Computers get small enough and cheap enoughthat it's practical for individuals to ownmicrocomputers, later called personal computers.Spooling (Simultaneous PeripheralOperation On Line) automaticallyqueued jobs to be loaded insteadof waiting until completion.Personal Computers . Intel 8080 - 8080 first general-purpose 8-bit CPU - Used in first microcpu with a disk . Xerox Alto (Xerox PARC) - GUI, mouse, Ethernet, WYSIWYG editor . oN Line System (NLS) - Doug Engelbert @ SRI Intl. - \"The Mother of All Demos\" - Windows, hypertext, graphics, mouse, word processing, VCS, collaborative real-time editing . CP/M - CP/M disk-based OS, written for a 8-inch 64kB memory floppy disk - Gary Kildall -&gt; Digital Research - Rewritten 1977 for more CPUs - Dominated microcomputing until 1982 - Introduced the BIOS . MS-DOS (86-DOS) - Released for IBM PC - A clone of CP/M by Tim Paterson for Intel 8086 - Acquired by Microsoft for ~$75k - Supplants CP/M after a year more commands, FAT file system . Berkeley Software Distribution (1BSD) - Bill Joy @ UC Berkeley CSRG - Originally added virtual memory to AT&amp;T Unix - Permissive licensing made it very popular (FOSS) - Later versions would introduce networking stack - vi text editor in 2BSD (1979) . Apple Lisa (Lisa OS) - First mass-market PC operable via GUI - Inspired by Xerox PARC GUI . UNIX System V (AT&amp;T) . Apple Macintosh 128K (macOS) - First successful mass-market all-in-one GUI PC - Built-in screen and mouse . Windows 1.0 (not an OS) - Microsoft's first GUI for MS-DOS - Calculator, Clock, Notepad, Control Panel, Paint, etc. MINIX - Andrew S. Tanenbaum @ VU Amsterdam - Educational UNIX clone - Microkernel architecture . Linux kernel - Linus Torvalds for x86 PCs - Free and Open-Source Software (FOSS) - Immediately saw variantsIntel 8080MS-DOS promptMacintosh 128K . FreeBSD . Solaris (from SunOS) . OpenBSD . Red Hat . OpenSUSE . Windows CE . NetBSD . Slackware . Debian . VxWorks . QNXOS landscape gets dominated by Microsoft, Apple, andLinux...Mobile Operating SystemsReal-Time Operating SystemsMiscellaneousOperating systems evolve alongside hardwareadvances and UI paradigms.People like free software.Examples:QNXZephyrfreeRTOSNuttXToaruOSTempleOSSerenityOSTockChibiOS/RTVxWorksThreadXApplications with time-critical constraints - can be soft or hard real-time - fast, deterministic response timesDesigns can be: - Event-driven (preemptive) - Time-sharing (round-robin)Often run in embedded systems1997 - Symbian1999 - Blackberry OS2007 - iOS2008 - Android2009 - Windows Phone2019 - HarmonyOS2021 - FuchsiaMobile ComputingOther Operating SystemsTakeaways1)2) . ",
    "url": "/lectures/lec02-template.html",
    
    "relUrl": "/lectures/lec02-template.html"
  },"9": {
    "doc": "Lecture 3 Annotated",
    "title": "Lecture 3 Annotated",
    "content": ". . . . . . 03 - OS Concepts and StructureOutlineConcept OverviewProcessesAddress SpaceFilesAnnouncementsReading: MOS 1.5, 1.7Concept OverviewMost systems have 2 execution modes: - user mode (non-privileged) - kernel mode (privileged)User mode execution restricts allowed actions andinstructions.For example, in ARM:- Move to/from system register- Read/Write protected memory- Enabling/Disabling interruptsCan only be done in privileged mode.User applications and general libs run in user-mode.Libraries (e.g. libc) can provide a common user-modeinterface for system calls.The OS manages processes.An address space is a range of valid memoryaddresses for a given process.Address space contains:- Readable and writeable by the process- Text: program code- Data: initialized global vars- BSS: uninitialized global vars- Heap: dynamically allocated vars- Stack: local varsA process is a program in execution.Each process has associated with it:The OS represents a process as a structcontaining the associated state information, whichis stored in an array called the process table.- an address space- current registers- resources: - open files - outstanding alarms/timers - related processes - etc.A program is a sequence of instructions (e.g. executable files ELF, EXE)(see )man -s 2 syscalls- File system service- Process management serviceUser-mode code must make a system call (syscall)to the kernel to access devices on its behalf.System calls can be grouped together to provideservices. For example:ProcessesAddress SpaceFilesSystem CallsKernelMake sure to join the Discord!PA 1 is due Friday.Start today if you haven't started yet!1)2)3)4)5)6) . Applications &amp; System Software . Non-privilegedInstructions . PrivilegedInstructions . I/O Devices . Libraries . OS Kernel . . . . . User . Library calls . System callsMachine inst. software . hardware . stack . heap . bss . data . text . Program Memory0xFFFFFFFF0x00000000Each process has its own addressspace, controlled by the OS.The file system is an OS abstraction forinteracting with storage devices.UNIX example:File paths:Storage devices can be mounted in the file systemFrom PA 1: /dev/sda0 -&gt; /From PA 1: /mnt/shared -&gt; /home/rtsang1/sharedSpecial Files and PseudofilesPipesInput/OutputSystem CallsExample: \"Hello World\"In UNIX, \"everything is a file\".A pipe is a pseudofile for allowing multipleprocesses to communicate via FIFO channelmanaged by the kernel.All computers have physical devices for receivinginput and generating output.Kernel manages I/O devices with I/O subsystemKernel requires device drivers to support hardwareUser-mode applications use system calls (syscalls)to issue service requests.Syscall mechanism is OS and hardware specific.- Less portable across platformsSyscalls are wrapped in system and standardlibraries (e.g. libc) to mitigate this.- Usually 1 function per syscall- libc based on C POSIX standard- libc different implementation per platformPortable, since all functions are from C stdlib.printf internals are different based on OS.3 ways of writing \"Hello World\" of increasingplatform dependence.printf(char *str, ...);write(int fd, char *buf, size_t len);write is an OS-specific POSIX-compliant libraryfunction, not the actual syscall.It makes a CPU-dependent syscall.Syscall interface is completely platformdependent.It is necessary for certain actions, like creatinga new process or interfacing with hardware.The kernel is the portion of the OS thatexecutes in privileged mode.It manages everything that requires privileged-mode operations (processes, interrupts, scheduling,I/O, etc.) and possibly more.3 types of kernel architecture:In a monolithic kernel, the entire OS executes inprivileged mode as one giant executable.Examples:- Most UNIX variants- Linux- Most BSD variantsIn a microkernel, the minimum necessary functionsare included in the kernel, all other functionalityprovided as user-mode modules.A hybrid kernel is a mixed approach.Only moves modules out of kernel if doing so does notnegatively affect performance.Improves reliability while prioritizing performance.- Kernel functions can call every other function- Performant- A single bug will crash the entire kernel- Very complex- Modules cannot interfere with one another- More resilience against module bugs- More communication overhead between modules- Monolithic kernel- Microkernel- Hybrid kernelA device driver implements initialization andcommunication logic for a specific device.The I/O subsystem provides a uniform file-likeAPI for accessing I/O devices.(e.g. keyboard, monitor, mouse, printer, etc.)- Must be created in advance- Processes see it as just another fileExample:Example:This shows output lines of `ls -l` onlyif the line contains \"D\".`|` pipes stdout of first process tostdin of next process.Special files make I/O devices look like files:(macOS example)Symbolic Links point to and act like other files.Named/Anonymous FIFOs (sockets/pipes) areused for inter-process communication.Block special files model devices withrandomly addressable blocks (e.g. disks)Character special files model devices thatuse character streams (e.g. serial ports)/home/rtsang1/.bashrc../.bashrcAbsolute ( / ):Relative (Documents):(Every process has a current working directory)/|-- home| `-- rtsang1|-- .bash_history|-- .bashrc|-- Documents|-- Downloads|-- .local| `-- .profile`-- tmp `-- dir `-- testA file is essentially a byte array.The OS provides syscalls to interact with files. (e.g. open, close, read, write files)Hierarchical file systems have directories.A directory is a special file that lists other files.The OS also provides syscalls for these. . . . . . . . /tmphomertsang1.localDocumentsdirDownloads.bashrctest . . . . . . brw-r----- 1 root operator 1, 0 Jan 5 23:20 /dev/disk0crw-rw-rw- 1 root wheel 4, 48 Jan 5 23:20 /dev/ttys0 . printf(char *str, ...);write(int fd, char *buf, size_t len);syscall(int number, ...); . KernelsMonolithic KernelMicrokernelHybrid Kernel . . . shell . shell . fs . fs . disk . disk . proc . proc . ipc . ipc . tty . tty . net . net . clock . clock . sys . sys . make . make . other . otherusermodekernelmodekernelmodeprocessesuserprogramsserversdriversinterrupts, drivers,scheduling, etc.interrupts, drivers,scheduling, etc.usermode . . . Examples:- Mach- MINIX- L4Examples:- Windows- XNU (Darwin)- DragonFly BSD . . . . . . . . . . . . . . . . . . . . . . . ls -l | grep -e \"D\" . ",
    "url": "/lectures/lec03-annotated.html",
    
    "relUrl": "/lectures/lec03-annotated.html"
  },"10": {
    "doc": "Lecture 3 Template",
    "title": "Lecture 3 Template",
    "content": ". . . . . . 03 - OS Concepts and StructureOutlineConcept OverviewProcessesAddress SpaceFilesAnnouncementsReading: MOS 1.5, 1.7Concept OverviewMost systems have 2 execution modes: - user mode (non-privileged) - kernel mode (privileged)User mode execution restricts allowed actions andinstructions.For example, in ARM:- Move to/from system register- Read/Write protected memory- Enabling/Disabling interruptsCan only be done in privileged mode.User applications and general libs run in user-mode.Libraries (e.g. libc) can provide a common user-modeinterface for system calls.The OS manages processes.An address space is a range of valid memoryaddresses for a given process.Address space contains:- Readable and writeable by the process- Text: program code- Data: initialized global vars- BSS: uninitialized global vars- Heap: dynamically allocated vars- Stack: local varsA process is a program in execution.Each process has associated with it:The OS represents a process as a structcontaining the associated state information, whichis stored in an array called the process table.- an address space- current registers- resources: - open files - outstanding alarms/timers - related processes - etc.A program is a sequence of instructions (e.g. executable files ELF, EXE)(see )man -s 2 syscalls- File system service- Process management serviceUser-mode code must make a system call (syscall)to the kernel to access devices on its behalf.System calls can be grouped together to provideservices. For example:ProcessesAddress SpaceFilesSystem CallsKernelMake sure to join the Discord!PA 1 is due Friday.Start today if you haven't started yet!1)2)3)4)5)6) . Applications &amp; System Software . Non-privilegedInstructions . PrivilegedInstructions . I/O Devices . Libraries . OS Kernel . . . . . User . Library calls . System callsMachine inst. software . hardware . stack . heap . bss . data . text . Program Memory0xFFFFFFFF0x00000000Each process has its own addressspace, controlled by the OS.The file system is an OS abstraction forinteracting with storage devices.UNIX example:File paths:Storage devices can be mounted in the file systemFrom PA 1: /dev/sda0 -&gt; /From PA 1: /mnt/shared -&gt; /home/rtsang1/sharedSpecial Files and PseudofilesPipesInput/OutputSystem CallsExample: \"Hello World\"In UNIX, \"everything is a file\".A pipe is a pseudofile for allowing multipleprocesses to communicate via FIFO channelmanaged by the kernel.All computers have physical devices for receivinginput and generating output.Kernel manages I/O devices with I/O subsystemKernel requires device drivers to support hardwareUser-mode applications use system calls (syscalls)to issue service requests.Syscall mechanism is OS and hardware specific.- Less portable across platformsSyscalls are wrapped in system and standardlibraries (e.g. libc) to mitigate this.- Usually 1 function per syscall- libc based on C POSIX standard- libc different implementation per platformPortable, since all functions are from C stdlib.printf internals are different based on OS.3 ways of writing \"Hello World\" of increasingplatform dependence.printf(char *str, ...);write(int fd, char *buf, size_t len);write is an OS-specific POSIX-compliant libraryfunction, not the actual syscall.It makes a CPU-dependent syscall.Syscall interface is completely platformdependent.It is necessary for certain actions, like creatinga new process or interfacing with hardware.The kernel is the portion of the OS thatexecutes in privileged mode.It manages everything that requires privileged-mode operations (processes, interrupts, scheduling,I/O, etc.) and possibly more.3 types of kernel architecture:In a monolithic kernel, the entire OS executes inprivileged mode as one giant executable.Examples:- Most UNIX variants- Linux- Most BSD variantsIn a microkernel, the minimum necessary functionsare included in the kernel, all other functionalityprovided as user-mode modules.A hybrid kernel is a mixed approach.Only moves modules out of kernel if doing so does notnegatively affect performance.Improves reliability while prioritizing performance.- Kernel functions can call every other function- Performant- A single bug will crash the entire kernel- Very complex- Modules cannot interfere with one another- More resilience against module bugs- More communication overhead between modules- Monolithic kernel- Microkernel- Hybrid kernelA device driver implements initialization andcommunication logic for a specific device.The I/O subsystem provides a uniform file-likeAPI for accessing I/O devices.(e.g. keyboard, monitor, mouse, printer, etc.)- Must be created in advance- Processes see it as just another fileExample:Example:This shows output lines of `ls -l` onlyif the line contains \"D\".`|` pipes stdout of first process tostdin of next process.Special files make I/O devices look like files:(macOS example)Symbolic Links point to and act like other files.Named/Anonymous FIFOs (sockets/pipes) areused for inter-process communication.Block special files model devices withrandomly addressable blocks (e.g. disks)Character special files model devices thatuse character streams (e.g. serial ports)/home/rtsang1/.bashrc../.bashrcAbsolute ( / ):Relative (Documents):(Every process has a current working directory)/|-- home| `-- rtsang1|-- .bash_history|-- .bashrc|-- Documents|-- Downloads|-- .local| `-- .profile`-- tmp `-- dir `-- testA file is essentially a byte array.The OS provides syscalls to interact with files. (e.g. open, close, read, write files)Hierarchical file systems have directories.A directory is a special file that lists other files.The OS also provides syscalls for these. . . . . . . . /tmphomertsang1.localDocumentsdirDownloads.bashrctest . . . . . . brw-r----- 1 root operator 1, 0 Jan 5 23:20 /dev/disk0crw-rw-rw- 1 root wheel 4, 48 Jan 5 23:20 /dev/ttys0 . printf(char *str, ...);write(int fd, char *buf, size_t len);syscall(int number, ...); . KernelsMonolithic KernelMicrokernelHybrid Kernel . . . shell . shell . fs . fs . disk . disk . proc . proc . ipc . ipc . tty . tty . net . net . clock . clock . sys . sys . make . make . other . otherusermodekernelmodekernelmodeprocessesuserprogramsserversdriversinterrupts, drivers,scheduling, etc.interrupts, drivers,scheduling, etc.usermode . . . Examples:- Mach- MINIX- L4Examples:- Windows- XNU (Darwin)- DragonFly BSD . obsidian://open?vault=teaching-vault&amp;file=courses%2Fcs492%2Flectures%2F03%2Flec03-template . ",
    "url": "/lectures/lec03-template.html",
    
    "relUrl": "/lectures/lec03-template.html"
  },"11": {
    "doc": "Lecture 4 Annotated",
    "title": "Lecture 4 Annotated",
    "content": ". . . . . . . . . . 04 - Computer Hardware ReviewOutlineWhy Review Hardware?Hardware ModelProcessorAnnouncementsReading: MOS 1.3Hardware ModelThe OS is fundamentally tied to hardware.- Must manage hardware resources for user- Must provide system calls for interactionWe saw from OS history that the entire purposeof an OS is to deal directly with hardware soprogrammers don't have to.Simplified model of a PC:A computer is composed of a CPU, memory, andI/O devices, all connected by a system bus.Modern computers are more complicated, but this isa decent enough model for us.The Central Processing Unit (CPU) performs allcomputations.CPU context (state) is held in registers.- General registers for data- Program counter for next instruction address- Stack pointer for top stack address- Status registers for execution informationA register is a small, very fast unit of memoryused to store data during active computation.CPU may need to switch between executingmultiple different programs.This is called a context switch.During a context switch, all the importantregisters need to be saved and restored fromkernel memory so programs execute correctly.Pipelined CPUs can process more than oneinstruction in stages for better performance.Superscalar CPUs improve performance further viaout-of-order execution.Multithreading/hyperthreading processorsincorporate hardware to support highly performantcontext switching.Multicore processors have multiple independentCPU cores in a single chip, allowing multiprocessing.(see MOS Figure 1-8)There are multiple different types of memory in acomputer used for different purposes.They are often arranged in a hierarchy organizedby size, performance, and cost.A cache temporarily holds data fetched fromslower memory in faster memory.Questions:Main memory is the addressable memory used byprocesses for just about everything.It is usually volatile (loses data on power loss).Details out of scope.Secondary memory is Non-volatile (persistent).There's lots of types:Hard Disk Drives are electromechanical, magneticstorage devices.I/O devices typically have a hardware controllerwith internal registers for configuration.Depending on the architecture, the processor canaccess these registers in one of 2 ways:I/O operations take a long time.There are 3 ways to check when they're done:Interrupts are important enough that they bearelaboration here.Interrupt hardware model (Fig 1-11a):Interrupt software model (Fig 1-11b):Things to note:It has been a long time since there has only beena single system bus in a computer.Now there are all sorts of buses everywhere, withmany protocols.&gt; Parallel Bus&gt; Shared (Bus)- Each word sent all at once- Faster- Larger footprint- Devices all connected to the same wires- Requires a bridge controller to manage- Each word sent one bit at a time- Slower- Smaller footprint- Devices connected to CPU separately- Requires switcher to manage connections&gt; Serial Bus&gt; Point-to-Point (P2P)Bus architectures:Many topologies. Here are just 2:Examples:PCI (legacy) - parallel, sharedPCIe - serial, P2PUSB - serial, starSATA - serial, P2P- Why?- A single bus limits data throughput- Kernel is always in memory- Kernel code is only executed on-demand via interrupt or system call- Most CPU time is spent in user-mode programsThe program calls into a device driver whichissues a command to the device controller.CPU hardware automatically checks for apending interrupt if interrupts are enabled.CPU hardware jumps directly to the kernel-mode interrupt handler function based on theprovided device id.The handler saves CPU context, handles theinterrupt, then restores the CPU context andreturns to the interrupted process.When device controller finishes, it signals theinterrupt controller using dedicated bus lines.When interrupt controller is ready, it sets apin on the CPU to signal a pending interrupt.The interrupt sets the device id of thepending interrupt so the CPU can process it.Most modern architectures now opt for MMIOPort-mapped I/O (port address space)Busy-waiting / PollingKeep checking the device status register.Have the device send a signal to the processor, which theprocessor manages with a context switch.Special hardware allows devices to directly write to addressablememory, triggering an interrupt when the transfer is complete.InterruptsDirect Memory Access (DMA)Memory-mapped I/O (shared address space)- Very cheap, massive storage- Long-term data reliability- Rather slow- Quite fast- No moving parts- Data degradationFloating Gate Transistorsstore bits via quantumtunneling.Solid State (Flash) Drives are non-volatileelectrical storage devices.- ROM (Read-only memory)- EEPROM (Electrically Erasable PROM)- Hard Disk- Flash/SSDSoftware Interface:get()returns hit if data present, miss otherwise- When to put new items in cache?- Which cache slot to put the new item in?- Which item to evict when cache full?- Where to put evicted items in memory?stores data in cacheRelated: cache coherencyset()- Hardware cache (e.g. L1, L2, L3) - managed by hardware, out of scope- Software cache (e.g. page cache, file cache)- Fetches instructions from memory, executes instructions, and updates memory- Each CPU has an Instruction Set Architecture (ISA) that defines the machine code format. ISAs are not portable.ProcessorMemoryI/O DevicesBusesMake sure to join the Discord!PA 1 is due Friday.Start today if you haven't started yet!1)2)3)4)5) . Memory . . VideoController . KeyboardController . USBController . HDDController . MMUCPUBus . I/O DevicesOn-board . Based on MOS Figure 1-6A simplified single-stage RISC-V processor datapath . . . . . . P&amp;H Figure 4.17Patterson, D. A., &amp; Hennessy, J. L. (2018). Computer Organizationand Design RISC-V Edition: The Hardware/Software Interface.Morgan Kaufmann. ISBN: 978-0128122754 . FetchUnit . FetchUnit . DecodeUnit . DecodeUnit . HoldingBuffer . ExecuteUnit . ExecuteUnit . ExecuteUnit . . . FetchUnit . DecodeUnit . ExecuteUnit . Simplified 3-stage pipeline from based on MOS Figure 1-7aSuperscalar CPU from MOS Figure 1-7b . . MemoryCachesMain Memory (RAM)Hard Disk Drive (HDD)Solid State Drive (SSD/Flash)I/O DevicesInterruptsBusesAdditional ReferencesSecondary MemoryRegistersLevelSizeThroughputLatencyL1 (Cache)L2 (Cache)L3 (Cache)RAM/Main(Primary)SSD(Secondary)HDD(Secondary) . . ~16 kB~256 GB/s~250 ps~1 ns~3 ns~10 ns~100 ns~200 us~4 ms~64 GB/s~18 GB/s~5 GB/s~60 GB/s~2 GB/s~500 MB/s~32 kB~1 MB~16-32 MB~4-64 GB~256 GB - 2 TB~1-18 TB . lowercost+largersize . higherperfValues based on wikipedia:Memory HierarchyDRAM CellSRAM CellDRAM used for Main MemorySRAM used for cacheHDD ComponentsHDD DiagramHDD Mechanism . SSD Controller . . . Host Interface . EmbeddedProcessor . BufferManager . FlashController . FlashController . FlashController . FlashMemory . FlashMemory . FlashMemory . FlashMemory . FlashMemory . FlashMemory . RAM Buffer . . . Flash CellSSD Architecture1)1)2)2)3)MOS Figure 1-111)1)2)3)2)3)4)Intel layout 2007MOS Figure 1-12Parallel vs. Serial Interface . . PCI vs PCIe TopologiesSome assets from Vecteezy.comMMU = Memory Management Unit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . temporal localityif you used an address, you are likely touse it again soon.if you used an address, you are likelyaddresses close byspacial locality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ",
    "url": "/lectures/lec04-annotated.html",
    
    "relUrl": "/lectures/lec04-annotated.html"
  },"12": {
    "doc": "Lecture 4 Template",
    "title": "Lecture 4 Template",
    "content": ". . . . . . . . . . 04 - Computer Hardware ReviewOutlineWhy Review Hardware?Hardware ModelProcessorAnnouncementsReading: MOS 1.3Hardware ModelThe OS is fundamentally tied to hardware.- Must manage hardware resources for user- Must provide system calls for interactionWe saw from OS history that the entire purposeof an OS is to deal directly with hardware soprogrammers don't have to.Simplified model of a PC:A computer is composed of a CPU, memory, andI/O devices, all connected by a system bus.Modern computers are more complicated, but this isa decent enough model for us.The Central Processing Unit (CPU) performs allcomputations.CPU context (state) is held in registers.- General registers for data- Program counter for next instruction address- Stack pointer for top stack address- Status registers for execution informationA register is a small, very fast unit of memoryused to store data during active computation.CPU may need to switch between executingmultiple different programs.This is called a context switch.During a context switch, all the importantregisters need to be saved and restored fromkernel memory so programs execute correctly.Pipelined CPUs can process more than oneinstruction in stages for better performance.Superscalar CPUs improve performance further viaout-of-order execution.Multithreading/hyperthreading processorsincorporate hardware to support highly performantcontext switching.Multicore processors have multiple independentCPU cores in a single chip, allowing multiprocessing.(see MOS Figure 1-8)There are multiple different types of memory in acomputer used for different purposes.They are often arranged in a hierarchy organizedby size, performance, and cost.A cache temporarily holds data fetched fromslower memory in faster memory.Questions:Main memory is the addressable memory used byprocesses for just about everything.It is usually volatile (loses data on power loss).Details out of scope.Secondary memory is Non-volatile (persistent).There's lots of types:Hard Disk Drives are electromechanical, magneticstorage devices.I/O devices typically have a hardware controllerwith internal registers for configuration.Depending on the architecture, the processor canaccess these registers in one of 2 ways:I/O operations take a long time.There are 3 ways to check when they're done:Interrupts are important enough that they bearelaboration here.Interrupt hardware model (Fig 1-11a):Interrupt software model (Fig 1-11b):Things to note:It has been a long time since there has only beena single system bus in a computer.Now there are all sorts of buses everywhere, withmany protocols.&gt; Parallel Bus&gt; Shared (Bus)- Each word sent all at once- Faster- Larger footprint- Devices all connected to the same wires- Requires a bridge controller to manage- Each word sent one bit at a time- Slower- Smaller footprint- Devices connected to CPU separately- Requires switcher to manage connections&gt; Serial Bus&gt; Point-to-Point (P2P)Bus architectures:Many topologies. Here are just 2:Examples:PCI (legacy) - parallel, sharedPCIe - serial, P2PUSB - serial, starSATA - serial, P2P- Why?- A single bus limits data throughput- Kernel is always in memory- Kernel code is only executed on-demand via interrupt or system call- Most CPU time is spent in user-mode programsThe program calls into a device driver whichissues a command to the device controller.CPU hardware automatically checks for apending interrupt if interrupts are enabled.CPU hardware jumps directly to the kernel-mode interrupt handler function based on theprovided device id.The handler saves CPU context, handles theinterrupt, then restores the CPU context andreturns to the interrupted process.When device controller finishes, it signals theinterrupt controller using dedicated bus lines.When interrupt controller is ready, it sets apin on the CPU to signal a pending interrupt.The interrupt sets the device id of thepending interrupt so the CPU can process it.Most modern architectures now opt for MMIOPort-mapped I/O (port address space)Busy-waiting / PollingKeep checking the device status register.Have the device send a signal to the processor, which theprocessor manages with a context switch.Special hardware allows devices to directly write to addressablememory, triggering an interrupt when the transfer is complete.InterruptsDirect Memory Access (DMA)Memory-mapped I/O (shared address space)- Very cheap, massive storage- Long-term data reliability- Rather slow- Quite fast- No moving parts- Data degradationFloating Gate Transistorsstore bits via quantumtunneling.Solid State (Flash) Drives are non-volatileelectrical storage devices.- ROM (Read-only memory)- EEPROM (Electrically Erasable PROM)- Hard Disk- Flash/SSDSoftware Interface:get()returns hit if data present, miss otherwise- When to put new items in cache?- Which cache slot to put the new item in?- Which item to evict when cache full?- Where to put evicted items in memory?stores data in cacheRelated: cache coherencyset()- Hardware cache (e.g. L1, L2, L3) - managed by hardware, out of scope- Software cache (e.g. page cache, file cache)- Fetches instructions from memory, executes instructions, and updates memory- Each CPU has an Instruction Set Architecture (ISA) that defines the machine code format. ISAs are not portable.ProcessorMemoryI/O DevicesBusesMake sure to join the Discord!PA 1 is due Friday.Start today if you haven't started yet!1)2)3)4)5) . Memory . . VideoController . KeyboardController . USBController . HDDController . MMUCPUBus . I/O DevicesOn-board . Based on MOS Figure 1-6A simplified single-stage RISC-V processor datapathP&amp;H Figure 4.17Patterson, D. A., &amp; Hennessy, J. L. (2018). Computer Organizationand Design RISC-V Edition: The Hardware/Software Interface.Morgan Kaufmann. ISBN: 978-0128122754 . FetchUnit . FetchUnit . DecodeUnit . DecodeUnit . HoldingBuffer . ExecuteUnit . ExecuteUnit . ExecuteUnit . . . FetchUnit . DecodeUnit . ExecuteUnit . Simplified 3-stage pipeline from based on MOS Figure 1-7aSuperscalar CPU from MOS Figure 1-7b . . MemoryCachesMain Memory (RAM)Hard Disk Drive (HDD)Solid State Drive (SSD/Flash)I/O DevicesInterruptsBusesAdditional ReferencesSecondary MemoryRegistersLevelSizeThroughputLatencyL1 (Cache)L2 (Cache)L3 (Cache)RAM/Main(Primary)SSD(Secondary)HDD(Secondary) . . ~16 kB~256 GB/s~250 ps~1 ns~3 ns~10 ns~100 ns~200 us~4 ms~64 GB/s~18 GB/s~5 GB/s~60 GB/s~2 GB/s~500 MB/s~32 kB~1 MB~16-32 MB~4-64 GB~256 GB - 2 TB~1-18 TB . lowercost+largersize . higherperfValues based on wikipedia:Memory HierarchyDRAM CellSRAM CellDRAM used for Main MemorySRAM used for cacheHDD ComponentsHDD DiagramHDD Mechanism . SSD Controller . . . Host Interface . EmbeddedProcessor . BufferManager . FlashController . FlashController . FlashController . FlashMemory . FlashMemory . FlashMemory . FlashMemory . FlashMemory . FlashMemory . RAM Buffer . . . Flash CellSSD Architecture1)1)2)2)3)MOS Figure 1-111)1)2)3)2)3)4)Intel layout 2007MOS Figure 1-12Parallel vs. Serial InterfacePCI vs PCIe TopologiesSome assets from Vecteezy.com . ",
    "url": "/lectures/lec04-template.html",
    
    "relUrl": "/lectures/lec04-template.html"
  },"13": {
    "doc": "Lecture 5 Annotated",
    "title": "Lecture 5 Annotated",
    "content": ". 05 - Intro to LinuxOutlineGoalsInterfacesInternalsSource CodePortable Operating System Interface (POSIX)Standard Utility ProgramsStandard LibraryAnnouncementsReading: MOS 10.2, LDD 1GoalsEvolved from UNIX Goals (not predefined):Torvalds started with his MINIX-based kernel, letmany other devs work on it, and Linux evolved vianatural selection from user feedback.There are several levels of interfaces used tointeract and program in the Linux environment.POSIX is published by IEEE and the Open GroupPOSIX defines standard system calls, programminginterfaces (libraries), and shell programs (UI)In \"core services\", among other things:- Process creation and control- Signals- File system operations- Pipes- C library- I/O port interface and control- Process triggersAlso required:- Synchronization primitives- Threads (pthread)- Shell- etc.Linux ships with a set of core set of utilityprograms:- File system manipulation- Text filters- Editors and compilers- System administration- Etc.GNU C standard library provides functions from Clanguage definitionKernel provides C definitions for system callsSystem calls are special assemblyinstructions and need to be exposed to Clanguage at compile time.syscall() is defined in a header, butimplemented in assembly, symbol visible atlink-time.(e.g. printf, scanf, etc.) see(e.g. read, write, fork, etc.)libc provides wrapper functions for convenienceon particular architectures.POSIX requires C standard functions and UNIXsystem calls to be defined, but not necessarilydefined by kernel.The kernel is modular and generally organizedaccording to functionality.The textbook presents a simplified view:Realistically, there is a lot more going on.Compiled kernel lives in /boot/vmlinuz-X.Y.ZSource download:Official Documentation:We will install as a package:Directory is 1.5 GB code -&gt; 20 GB compiledInteresting directories:Useful exploration tools:Bootlin (web-based code indexing tool)Cscope (TUI code indexer/browser)- Browse code of different Linux versions- Search for symbols/identifiers- Look up declarations and definitions- Install:- Index:- Start:- Exit:- Search: - C identifiers/symbols (e.g. start_kernel) - Function/variable definitions - Function calls - Strings- Usage: - `tab`: switch between menu and results - `arrows`: move between menu items - `space`: see more results - `enter`: search or select item (opens vi)- Check source tree version:- For a particular version:- bootloader will allow you to select one- see current version with `uname -a`kernel.org/pub/linux/kernel/vX.Y/linux-X.Y.Z.tar.{gz|xz}sudo apt install linux-sourcemake kernelversionExamples from MOS Figure 10-2:The current version isThese interfaces are mostly compliant with thePOSIX standard.- Multiuser, modular, monolithic kernel- Everything is a file- Free and Open Source Software (FOSS)But modern Linux does not adhere completely.\"UNIX Philosophy\":- Douglas McIlroy (invented the UNIX pipe)- Make it easy to write, test, and run programs- Economy/Elegance due to size constraints- Constant maintenance &amp; improvementWrite programs that do one thing and do it well.Write programs that work together.Write programs to handle text streams, because that is a universal interface.InterfacesInternalsPA 1 is due today. I hope you started.I will release PA2 instructions by tonight.1)2)3) . Users . Standard Utility Programs(shell, editor, compilers, etc.) . Standard Library(open, close, read, write, fork, etc.) . Linux Kernel(proc management, mem management, file system, I/O, etc.) . Hardware(CPU, memory, disks, terminals, etc.) . . UserInterfaceLibraryInterfaceSyscallInterfaceMOS Figure 10-1POSIX.1-2024catchmodcpcutgrepheadlsmakeodpasteprpsrmrmdirsorttailtrmkdirconcatenate files and print on the standard outputchange file mode bitscopy files and directoriesremove sections from each line of filesprint lines that match patternsoutput the first part of fileslist directory contentsGNU make utility to maintain groups of programsmake directoriesdump files in octal and other formatsmerge lines of filesconvert text files for printingreport a snapshot of the current processesremove files or directoriesremove empty directoriessort lines of text filesoutput the last part of filestranslate or delete characterssyscall: ; Use the 'read' syscall (number 0) from stdin (fd 0) ; mov rax, 0 ; syscall number for 'read' ; mov rdi, 0 ; file descriptor 0 (stdin) ; mov rsi, buffer ; address of buffer to store input ; mov rdx, buffer_len; maximum number of bytes to read syscall ; invoke kernelseeCygwin,WSL1C StandardMOS Figure 10-3Linux Kernel Mapinteractive diagraminteractive mapLinux Kernel Archivesdocs.kernel.orgarch/sudo apt install cscopemake cscopecscopeCtrl-dISA-specific code (boot process, context switch, etc.)header fileskernel initialization code (not arch-specific)memory managementdevice driversinter-process communicationfile systemgeneric kernel corenetworkingblock memory deviceshelper/utility librariesconfig and compilation scriptsself-explanatoryfunction/mechanism examplesuser space programs/scripts for debugging, tracing, etc.include/init/mm/drivers/ipc/fs/kernel/net/block/lib/scripts/Documentation/samples/tools/// syscall.hint syscall(int num, ...);// syscall.asmsyscall: syscall . . . ",
    "url": "/lectures/lec05-annotated.html",
    
    "relUrl": "/lectures/lec05-annotated.html"
  },"14": {
    "doc": "Lecture 5 Template",
    "title": "Lecture 5 Template",
    "content": ". 05 - Intro to LinuxOutlineGoalsInterfacesInternalsSource CodePortable Operating System Interface (POSIX)Standard Utility ProgramsStandard LibraryAnnouncementsReading: MOS 10.2, LDD 1GoalsEvolved from UNIX Goals (not predefined):Torvalds started with his MINIX-based kernel, letmany other devs work on it, and Linux evolved vianatural selection from user feedback.There are several levels of interfaces used tointeract and program in the Linux environment.POSIX is published by IEEE and the Open GroupPOSIX defines standard system calls, programminginterfaces (libraries), and shell programs (UI)In \"core services\", among other things:- Process creation and control- Signals- File system operations- Pipes- C library- I/O port interface and control- Process triggersAlso required:- Synchronization primitives- Threads (pthread)- Shell- etc.Linux ships with a set of core set of utilityprograms:- File system manipulation- Text filters- Editors and compilers- System administration- Etc.GNU C standard library provides functions from Clanguage definitionKernel provides C definitions for system callsSystem calls are special assemblyinstructions and need to be exposed to Clanguage at compile time.syscall() is defined in a header, butimplemented in assembly, symbol visible atlink-time.(e.g. printf, scanf, etc.) see(e.g. read, write, fork, etc.)libc provides wrapper functions for convenienceon particular architectures.POSIX requires C standard functions and UNIXsystem calls to be defined, but not necessarilydefined by kernel.The kernel is modular and generally organizedaccording to functionality.The textbook presents a simplified view:Realistically, there is a lot more going on.Compiled kernel lives in /boot/vmlinuz-X.Y.ZSource download:Official Documentation:We will install as a package:Directory is 1.5 GB code -&gt; 20 GB compiledInteresting directories:Useful exploration tools:Bootlin (web-based code indexing tool)Cscope (TUI code indexer/browser)- Browse code of different Linux versions- Search for symbols/identifiers- Look up declarations and definitions- Install:- Index:- Start:- Exit:- Search: - C identifiers/symbols (e.g. start_kernel) - Function/variable definitions - Function calls - Strings- Usage: - `tab`: switch between menu and results - `arrows`: move between menu items - `space`: see more results - `enter`: search or select item (opens vi)- Check source tree version:- For a particular version:- bootloader will allow you to select one- see current version with `uname -a`kernel.org/pub/linux/kernel/vX.Y/linux-X.Y.Z.tar.{gz|xz}sudo apt install linux-sourcemake kernelversionExamples from MOS Figure 10-2:The current version isThese interfaces are mostly compliant with thePOSIX standard.- Multiuser, modular, monolithic kernel- Everything is a file- Free and Open Source Software (FOSS)But modern Linux does not adhere completely.\"UNIX Philosophy\":- Douglas McIlroy (invented the UNIX pipe)- Make it easy to write, test, and run programs- Economy/Elegance due to size constraints- Constant maintenance &amp; improvementWrite programs that do one thing and do it well.Write programs that work together.Write programs to handle text streams, because that is a universal interface.InterfacesInternalsPA 1 is due today. I hope you started.I will release PA2 instructions by tonight.1)2)3) . Users . Standard Utility Programs(shell, editor, compilers, etc.) . Standard Library(open, close, read, write, fork, etc.) . Linux Kernel(proc management, mem management, file system, I/O, etc.) . Hardware(CPU, memory, disks, terminals, etc.) . . UserInterfaceLibraryInterfaceSyscallInterfaceMOS Figure 10-1POSIX.1-2024catchmodcpcutgrepheadlsmakeodpasteprpsrmrmdirsorttailtrmkdirconcatenate files and print on the standard outputchange file mode bitscopy files and directoriesremove sections from each line of filesprint lines that match patternsoutput the first part of fileslist directory contentsGNU make utility to maintain groups of programsmake directoriesdump files in octal and other formatsmerge lines of filesconvert text files for printingreport a snapshot of the current processesremove files or directoriesremove empty directoriessort lines of text filesoutput the last part of filestranslate or delete characters; Use the 'read' syscall (number 0) from stdin (fd 0)mov rax, 0 ; syscall number for 'read'mov rdi, 0 ; file descriptor 0 (stdin)mov rsi, buffer ; address of buffer to store inputmov rdx, buffer_len; maximum number of bytes to readsyscall ; invoke kernelseeCygwin,WSL1C StandardMOS Figure 10-3Linux Kernel Mapinteractive diagraminteractive mapLinux Kernel Archivesdocs.kernel.orgarch/ISA-specific code (boot process, context switch, etc.)header fileskernel initialization code (not arch-specific)memory managementdevice driversinter-process communicationfile systemgeneric kernel corenetworkingblock memory deviceshelper/utility librariesconfig and compilation scriptsself-explanatoryfunction/mechanism examplesuser space programs/scripts for debugging, tracing, etc.include/init/mm/drivers/ipc/fs/kernel/net/block/lib/scripts/Documentation/samples/tools/sudo apt install cscopemake cscopecscopeCtrl-d . ",
    "url": "/lectures/lec05-template.html",
    
    "relUrl": "/lectures/lec05-template.html"
  },"15": {
    "doc": "Lecture 6 Annotated",
    "title": "Lecture 6 Annotated",
    "content": ". . . 06 - Intro to LinuxOutlineKernel DevelopmentConfigurationBuild ProcessAnnouncementsReading: MOS 10.2, LDD 1Kernel DevelopmentAfter obtaining kernel source (see last lecture).4 steps for basic development:Configure kernel features- a lot of code for different hardware, don't enable all of it- `.config` file to enable/disable feature flagsmake menuconfigsudo make INSTALL_MOD_STRIP=1 modules_installsudo make installmake menuconfigmake -j $(nproc)/lib/modules-- compile with max possible cores:- modules need to be compiled for specific kernel versions- modules installed separately in ---- very long wait (~1.5 hr 4 cores; 5.5 hrs 8 cores emulated)Compile kernelInstall kernel modules (as root)Install kernel (as root)A `.config` file is needed in the kernel directory.Steps:Easier to copy the config file for the currentrunning kernelconfig files have thousands of non-obviousfeature flags. It's easier to configure via TUI:- Each config file for corresponding built kernels are available in `/boot`- Select based on current running versionKernel Module DevelopmentQuiz 1 will be on Friday, first 10 min of class.10 MCQ online, no cheat sheet.Don't be late!PA 2 released, but later portions require updates.You can still start the first 2 parts after thislecture.1)1)2)2)3)4)Copy current kernel configcp /boot/config-$(uname -r) .configmake menuconfigmake -j $(nproc) allsudo make INSTALL_MOD_STRIP=1 modules_installsudo make installsudo update-grub/boot---- wait hours...-- copies compiled kernel and config to- select new kernel from GRUB menu- must reboot to switch kernels or if kernel crashes--Modify kernel configCompile kernelInstall kernel modules (as root)Install kernel (as root)Update bootloader (distro-dependent)Reboot with new kernel1)2)4)3)5)6)7)Basic configurations are available in `arch/`,but these are missing a lot of details.ls arch/x86/configs/ls /boot/config-*uname -aKernel Module DevelopmentWorking with Kernel ModulesKernel Module ExampleDynamically loadable modules (kernel extensions)Kernel modules run in kernel-mode.They can touch everything.Often used for:Kernel modules are version specific.Statically compiled kernel modules- loaded manually, requires root permissions- don't need to recompile entire kernel -&gt; faster kernel-mode development- \"linux kernel module\" usually refers to this- crashes can crash the whole kernel- potential security risk- device drivers- file system drivers- networking protocols (except TCP/IP)- compiled as part of kernel- often necessary for kernel functionCodeDevelopment:We'll do an example \"hello world\" module.To build it, we need to create a Makefile to invokethe kernel build system, since the module needs tobe linked against a specific kernel version.In action:Kernel Module Commands- loads kernel module by path- unloads kernel module by name- lists loaded modules (/proc/modules)- print info about a kernel module- description, version, parameters, authors, etc.- advanced module loading- modules from kernel sources are at /lib/modules/&lt;kversion&gt;/- handles module dependencies (we probably won't be using it)- generates dependency list at /lib/modules/&lt;kversion&gt;/modules.dep- remove with `-r` flaginsmod &lt;module_path&gt;rmmod &lt;module_name&gt;lsmodmodinfo &lt;module_path&gt;modprobe &lt;module_name&gt;Requires Linux kernel to link againstDrastically shortens development cycle- compiled kernel source tree- header files and libraries- quickly load/unload, no reboot required- no need to recompile huge portions of kernelCompileLoadUseUnload1)2)4)3)5)Available Kernel FunctionsModules are linked against the full kernelKernel symbol table available at:C standard library is not generally available- kernel's printf equivalent (same function args)- messages must start with a- does not print to stdout, but to kernel log - filtered by log level - don't forget `\\n`, otherwise output buffered.Kernel Module LibrariesprintkKernel modules can expose symbols for othermodules to use module functionality.- KERN_EMERG- KERN_ALERT- KERN_CIRT- KERN_ERR- KERN_WARNING- KERN_NOTICE- KERN_INFO- KERN_DEBUG- EXPORT_SYMBOL(name);- EXPORT_SYMBOL_GPL(name);- all kernel functions in-scope, including - global variables - exported functions- similar functions available in helper libraries- /proc/kallsyms- /boot/System.map-*int printk(const char *fmt, ...)log level . ",
    "url": "/lectures/lec06-annotated.html",
    
    "relUrl": "/lectures/lec06-annotated.html"
  },"16": {
    "doc": "Lecture 6 Template",
    "title": "Lecture 6 Template",
    "content": ". . . 06 - Intro to LinuxOutlineKernel DevelopmentConfigurationBuild ProcessAnnouncementsReading: MOS 10.2, LDD 1Kernel DevelopmentAfter obtaining kernel source (see last lecture).4 steps for basic development:Configure kernel features- a lot of code for different hardware, don't enable all of it- `.config` file to enable/disable feature flagsmake menuconfigsudo make INSTALL_MOD_STRIP=1 modules_installsudo make installmake menuconfigmake -j $(nproc)/lib/modules-- compile with max possible cores:- modules need to be compiled for specific kernel versions- modules installed separately in ---- very long wait (~1.5 hr 4 cores; 5.5 hrs 8 cores emulated)Compile kernelInstall kernel modules (as root)Install kernel (as root)A `.config` file is needed in the kernel directory.Steps:Easier to copy the config file for the currentrunning kernelconfig files have thousands of non-obviousfeature flags. It's easier to configure via TUI:- Each config file for corresponding built kernels are available in `/boot`- Select based on current running versionKernel Module DevelopmentQuiz 1 will be on Friday, first 10 min of class.10 MCQ online, no cheat sheet.Don't be late!PA 2 released, but later portions require updates.You can still start the first 2 parts after thislecture.1)1)2)2)3)4)Copy current kernel configcp /boot/config-$(uname -r) .configmake menuconfigmake -j $(nproc) allsudo make INSTALL_MOD_STRIP=1 modules_installsudo make installsudo update-grub/boot---- wait hours...-- copies compiled kernel and config to- select new kernel from GRUB menu- must reboot to switch kernels or if kernel crashes--Modify kernel configCompile kernelInstall kernel modules (as root)Install kernel (as root)Update bootloader (distro-dependent)Reboot with new kernel1)2)4)3)5)6)7)Basic configurations are available in `arch/`,but these are missing a lot of details.ls arch/x86/configs/ls /boot/config-*uname -aKernel Module DevelopmentWorking with Kernel ModulesKernel Module ExampleDynamically loadable modules (kernel extensions)Kernel modules run in kernel-mode.They can touch everything.Often used for:Kernel modules are version specific.Statically compiled kernel modules- loaded manually, requires root permissions- don't need to recompile entire kernel -&gt; faster kernel-mode development- \"linux kernel module\" usually refers to this- crashes can crash the whole kernel- potential security risk- device drivers- file system drivers- networking protocols (except TCP/IP)- compiled as part of kernel- often necessary for kernel functionCodeDevelopment:We'll do an example \"hello world\" module.To build it, we need to create a Makefile to invokethe kernel build system, since the module needs tobe linked against a specific kernel version.In action:Kernel Module Commands- loads kernel module by path- unloads kernel module by name- lists loaded modules (/proc/modules)- print info about a kernel module- description, version, parameters, authors, etc.- advanced module loading- modules from kernel sources are at /lib/modules/&lt;kversion&gt;/- handles module dependencies (we probably won't be using it)- generates dependency list at /lib/modules/&lt;kversion&gt;/modules.dep- remove with `-r` flaginsmod &lt;module_path&gt;rmmod &lt;module_name&gt;lsmodmodinfo &lt;module_path&gt;modprobe &lt;module_name&gt;Requires Linux kernel to link againstDrastically shortens development cycle- compiled kernel source tree- header files and libraries- quickly load/unload, no reboot required- no need to recompile huge portions of kernelCompileLoadUseUnload1)2)4)3)5)Available Kernel FunctionsModules are linked against the full kernelKernel symbol table available at:C standard library is not generally available- kernel's printf equivalent (same function args)- messages must start with a- does not print to stdout, but to kernel log - filtered by log level - don't forget `\\n`, otherwise output buffered.Kernel Module LibrariesprintkKernel modules can expose symbols for othermodules to use module functionality.- KERN_EMERG- KERN_ALERT- KERN_CIRT- KERN_ERR- KERN_WARNING- KERN_NOTICE- KERN_INFO- KERN_DEBUG- EXPORT_SYMBOL(name);- EXPORT_SYMBOL_GPL(name);- all kernel functions in-scope, including - global variables - exported functions- similar functions available in helper libraries- /proc/kallsyms- /boot/System.map-*int printk(const char *fmt, ...)log level . ",
    "url": "/lectures/lec06-template.html",
    
    "relUrl": "/lectures/lec06-template.html"
  },"17": {
    "doc": "Lecture 7 Annotated",
    "title": "Lecture 7 Annotated",
    "content": ". . . 07 - System CallsOutlineSyscalls RecapSyscall ImplementationExample: gettimeofdayMemory AccessAdding a Syscall to LinuxCommentsSyscall MechanismExamplesAnnouncementsReading: MOS 1.6Syscalls RecapSyscall MechanismSyscall ImplementationQuiz 1 will be on Friday, first 10 min of class.10 MCQ online, no cheat sheet.Don't be late!It will include content from today!Rest of PA2 released. If I'm quick, we'll getthrough almost everything you need today.System calls are the kernel's API for user-modeprograms to interact with hardware and system-critical functions.User-mode programs - see syscalls as normal functions - cannot access kernel stuffSystem Call requires CPU context switchSystem Calls are OS-dependent, often not portableHardware invocation mechanism is arch dependent2 general approaches:Syscall parameters are passed via registers.For example, in x86 assembly:On the syscall instruction, the CPU:Hardware saves program counterHardware jumps to entry in kernel-modeKernel assembly procedure saves registersKernel initializes new stack and dispatchesSystem call code runsScheduler decides which process to return toKernel assembly restores process contextKernel restores PC and leaves kernel modeThen the kernel entry code takes over.Kernel entry code determines which syscall toinvoke by looking up the syscall number in a table.Internal prototypes:Arch-specific:Syscall Table:Macro SYSCALL_DEFINE2 declares a syscall with2 arguments. For each argument, the macro takesthe type and name as separate fields.Return value will be returned to user process.copy_{to/from}_user copies data between kerneland process address space.Important:Kernel should never trust the user!Kernel should not abuse its powers!Kernel should copy user data to kernel spacebefore manipulating it, then copy it back to userspace.User Space Memory Access API:Write your syscall functionTo add your syscall to the build system:Pros: - Adding syscalls is \"easy\"Cons: - Need official syscall number - Interface changes are permanent - Must be registered for every architecture - Not always necessaryAlternative: - Device or virtual file (kernel modules) - Can alter behavior of existing syscalls (e.g. read, write, ioctl)- Add a file: - Modify top-level Makefile:- contents:- contents:(Assume syscall code @ )Add syscall to syscall table (arch-specific)Add syscall prototype to header fileRebuild and reinstall kernelTest with libc syscall function from user code- In an existing file (not for PA 2)- x86: - Use tabs between fields- common:- or arch-specific equivalent- Recompile kernel- Reinstall modules- Reinstall kernel- Reboot with new kernel- In an new file if self-contained - Add file to build system- User-space cannot access kernel-space memory- Kernel-space can access user-space memory- Kernel must check user-provided pointers- Kernel must never execute user-space memory- Minimize access to user-space memorythe table is used by the Linux build systemTrap Modelcolumn 1:column 2:column 3:column 4:syscall numberarchitecture availabilitysyscall nameinternal function name- Similar to hardware interrupt mechanismInterrupt InstructionSpecial InstructionIdea: fake an interrupt (hardware interrupts trigger kernel-mode)Idea: special hardware logic to perform mode and context switchEx. Intel &amp; AMD originally had sysenter/syscall, with differenthardware mechanisms. Now, both use syscall in 64-bit systemse.g. UNIX calls completely different from WindowsKernel code only executes under 2 conditions:(See also MOS Figure 1-18)Process ManagementFile SystemMiscellaneous- hardware access - read/write/manage files in storage devices - read/write to I/O devices- create processes- change security permissions- interrupt- system call1)2)3)pid = fork()pid = waitpid(pid, &amp;statloc, options)s = execve(name, argv, environp)exit(status)create a child process identical to parentwait for child to terminatereplace a process's core imageterminate process execution and return statusfd = open(file, mode, ...)s = close(fd)n = read(fd, buffer, len)n = write(fd, buffer, len)pos = lseek(fd, offset, whence)s = stat(name, &amp;buf)s = mkdir(name, mode)s = rmdir(name)s = link(name1, name2)s = unlink(name)s = mount(special, name, flag)s = unmount(special)open a fileclose an open fileread data from file to bufferwrite data from buffer to filemove the file pointerget file status informationcreate directoryremove empty directorycreate an entry name2 that points to name1remove an entrymount a file systemunmount a file systems = chdir(dirname)s = chmod(name, mode)s = kill(pid, signal)sec = time(&amp;seconds)change working directorychange file's protection bitssend signal to processget seconds since 1/1/1970 . User Mode Process . User Mode Process . Kernel Mode Execution . syscall invokedsyscall returns . time- Enters kernel code, different address range &gt; Kernel checks calling process permissions- Changes execution mode (user -&gt; kernel) &gt; Recall the CPU status/control register(1):&gt;1)1)2)3)4)5)2)3)4)5)6)7)8)&gt;&gt;(2): .textENTRY (syscall) movq %rdi, %rax /* Syscall number -&gt; rax. */ movq %rsi, %rdi /* shift arg1 - arg5. */ movq %rdx, %rsi movq %rcx, %rdx movq %r8, %r10 movq %r9, %r8 movq 8(%rsp),%r9 /* arg6 is on the stack. */ syscall /* Do the system call. */ cmpq $-4095, %rax /* Check %rax for error. */ jae SYSCALL_ERROR_LABEL /* Jump to error handler if error. */ ret /* Return to caller. */PSEUDO_END (syscall)(from glibc source)Saves the process's next instruction addressJumps to fixed kernel entry pointUpdates ctrl/stat register to kernel-modearch/x86/entry/entry_64.Sarch/x86/entry/syscalls/syscall_64.tbldo_syscall_64seeseeseesimilar to interrupts in MOS Figure 2-5Resume a user-mode processSteps 6-8:Step 5:Executes system call properSteps 1-4:Hardware &amp; assembly save context . . . . . . . . MOS Figure 1-17include/linux/syscalls.hinclude/linux/syscalls.harch/x86/include/asm/syscalls.hkernel/time/time.cuaccess.hget_userGets a simple variable from user spacePuts a simple variable to user spaceClears a block in user spaceCopies a block from kernel to user spaceCopies a block from user to kernel spaceGets length of a string buffer in user spaceCopies a string from user to kernel spaceput_userclear_usercopy_to_usercopy_from_userstrnlen_userstrncpy_from_userarch/x86/entry/syscalls/syscall_64.tblarch/x86/entry/syscalls/syscall_64.tblinclude/linux/syscalls.hsee . KernelSpace . UserSpace . Forbidden . Dangerousmy_syscall/my_syscall.cmy_syscall/Makefileobj-y += my_syscall.ocore-y := my_syscall/ . . . . . . . . . . . . . . . . . . . . . . . . . . . . MOS Figure 1-21 . MOS Figure 1-22the same file can have multiple names using linkUNIX puts everything in a single tree, newstorage devices with their own tree need tobe added to the root tree. ",
    "url": "/lectures/lec07-annotated.html",
    
    "relUrl": "/lectures/lec07-annotated.html"
  },"18": {
    "doc": "Lecture 7 Template",
    "title": "Lecture 7 Template",
    "content": ". . . 07 - System CallsOutlineSyscalls RecapSyscall ImplementationExample: gettimeofdayMemory AccessAdding a Syscall to LinuxCommentsSyscall MechanismExamplesAnnouncementsReading: MOS 1.6Syscalls RecapSyscall MechanismSyscall ImplementationQuiz 1 will be on Friday, first 10 min of class.10 MCQ online, no cheat sheet.Don't be late!It will include content from today!Rest of PA2 released. If I'm quick, we'll getthrough almost everything you need today.System calls are the kernel's API for user-modeprograms to interact with hardware and system-critical functions.User-mode programs - see syscalls as normal functions - cannot access kernel stuffSystem Call requires CPU context switchSystem Calls are OS-dependent, often not portableHardware invocation mechanism is arch dependent2 general approaches:Syscall parameters are passed via registers.For example, in x86 assembly:On the syscall instruction, the CPU:Hardware saves program counterHardware jumps to entry in kernel-modeKernel assembly procedure saves registerskernel initializes new stack and dispatchesSystem call code runsScheduler decides which process to return toKernel assembly restores process contextKernel restores PC and leaves kernel modeThen the kernel entry code takes over.Kernel entry code determines which syscall toinvoke by looking up the syscall number in a table.Internal prototypes:Arch-specific:Syscall Table:Macro SYSCALL_DEFINE2 declares a syscall with2 arguments. For each argument, the macro takesthe type and name as separate fields.Return value will be returned to user process.copy_{to/from}_user copies data between kerneland process address space.Important:Kernel should never trust the user!Kernel should not abuse its powers!Kernel should copy user data to kernel spacebefore manipulating it, then copy it back to userspace.User Space Memory Access API:Write your syscall functionTo add your syscall to the build system:Pros: - Adding syscalls is \"easy\"Cons: - Need official syscall number - Interface changes are permanent - Must be registered for every architecture - Not always necessaryAlternative: - Device or virtual file (kernel modules) - Can alter behavior of existing syscalls (e.g. read, write, ioctl)- Add a file: - Modify top-level Makefile:- contents:- contents:(Assume syscall code @ )Add syscall to syscall table (arch-specific)Add syscall prototype to header fileRebuild and reinstall kernelTest with libc syscall function from user code- In an existing file (not for PA 2)- x86: - Use tabs between fields- common:- or arch-specific equivalent- Recompile kernel- Reinstall modules- Reinstall kernel- Reboot with new kernel- In an new file if self-contained - Add file to build system- User-space cannot access kernel-space memory- Kernel-space can access user-space memory- Kernel must check user-provided pointers- Kernel must never execute user-space memory- Minimize access to user-space memorythe table is used by the Linux build systemTrap Modelcolumn 1:column 2:column 3:column 4:syscall numberarchitecture availabilitysyscall nameinternal function name- Similar to hardware interrupt mechanismInterrupt InstructionSpecial InstructionIdea: fake an interrupt (hardware interrupts trigger kernel-mode)Idea: special hardware logic to perform mode and context switchEx. Intel &amp; AMD originally had sysenter/syscall, with differenthardware mechanisms. Now, both use syscall in 64-bit systemse.g. UNIX calls completely different from WindowsKernel code only executes under 2 conditions:(See also MOS Figure 1-18)Process ManagementFile SystemMiscellaneous- hardware access - read/write/manage files in storage devices - read/write to I/O devices- create processes- change security permissions- interrupt- system call1)2)3)pid = fork()pid = waitpid(pid, &amp;statloc, options)s = execve(name, argv, environp)exit(status)create a child process identical to parentwait for child to terminatereplace a process's core imageterminate process execution and return statusfd = open(file, mode, ...)s = close(fd)n = read(fd, buffer, len)n = write(fd, buffer, len)pos = lseek(fd, offset, whence)s = stat(name, &amp;buf)s = mkdir(name, mode)s = rmdir(name)s = link(name1, name2)s = unlink(name)s = mount(special, name, flag)s = unmount(special)open a fileclose an open fileread data from file to bufferwrite data from buffer to filemove the file pointerget file status informationcreate directoryremove empty directorycreate an entry name2 that points to name1remove an entrymount a file systemunmount a file systems = chdir(dirname)s = chmod(name, mode)s = kill(pid, signal)sec = time(&amp;seconds)change working directorychange file's protection bitssend signal to processget seconds since 1/1/1970 . User Mode Process . User Mode Process . Kernel Mode Execution . syscall invokedsyscall returns . time- Enters kernel code, different address range &gt; Kernel checks calling process permissions- Changes execution mode (user -&gt; kernel) &gt; Recall the CPU status/control register(1):&gt;1)1)2)3)4)5)2)3)4)5)6)7)8)&gt;&gt;(2): .textENTRY (syscall) movq %rdi, %rax /* Syscall number -&gt; rax. */ movq %rsi, %rdi /* shift arg1 - arg5. */ movq %rdx, %rsi movq %rcx, %rdx movq %r8, %r10 movq %r9, %r8 movq 8(%rsp),%r9 /* arg6 is on the stack. */ syscall /* Do the system call. */ cmpq $-4095, %rax /* Check %rax for error. */ jae SYSCALL_ERROR_LABEL /* Jump to error handler if error. */ ret /* Return to caller. */PSEUDO_END (syscall)(from glibc source)Saves the process's next instruction addressJumps to fixed kernel entry pointUpdates ctrl/stat register to kernel-modearch/x86/entry/entry_64.Sarch/x86/entry/syscalls/syscall_64.tbldo_syscall_64seeseeseesimilar to interrupts in MOS Figure 2-5Resume a user-mode processSteps 6-8:Step 5:Executes system call properSteps 1-4:Hardware &amp; assembly save contextMOS Figure 1-17include/linux/syscalls.hinclude/linux/syscalls.harch/x86/include/asm/syscalls.hkernel/time/time.cuaccess.hget_userGets a simple variable from user spacePuts a simple variable to user spaceClears a block in user spaceCopies a block from kernel to user spaceCopies a block from user to kernel spaceGets length of a string buffer in user spaceCopies a string from user to kernel spaceput_userclear_usercopy_to_usercopy_from_userstrnlen_userstrncpy_from_userarch/x86/entry/syscalls/syscall_64.tblarch/x86/entry/syscalls/syscall_64.tblinclude/linux/syscalls.hsee . KernelSpace . UserSpace . Forbidden . Dangerousmy_syscall/my_syscall.cmy_syscall/Makefileobj-y += my_syscall.ocore-y := my_syscall/ . ",
    "url": "/lectures/lec07-template.html",
    
    "relUrl": "/lectures/lec07-template.html"
  },"19": {
    "doc": "Programming Assignment 1",
    "title": "1 - Description",
    "content": "Warning: you must read everything carefully and be sure to complete all steps for your machine. Skipping steps can lead to unrecoverable states and you may be forced to fully restart the assignment. Fully read the instructions for each step before doing that step. The goal of this assignment is for you to learn how to install different Unix-based operating systems: . | OpenBSD | Arch Linux | Debian (which we will use for subsequent assignments) | . In CS 382 and CS 385, you may have learned how to install Ubuntu, but were likely relying on the installation software. In this assignment, you will be doing the installations manually to get a better understanding of the steps required to install a new operating system. Terms: . | â€œhostâ€: your own physical computer running either Windows or macOS. | â€œguestâ€: a virtual machine (VM) running a Unix-based operating system. | . ",
    "url": "/assignments/pa1.html#loc-1",
    
    "relUrl": "/assignments/pa1.html#loc-1"
  },"20": {
    "doc": "Programming Assignment 1",
    "title": "contents",
    "content": ". | 1 - Description | 2 - Preliminary Steps | 3 - OS-Specific Steps . | 3.1 - Windows | 3.2 - Macos . | 3.2.1 - UTM | . | . | 4 - Installing Virtualbox . | 4.1 - Virtualbox Application | 4.2 - Virtualbox Guest Additions | . | 5 - Installing Openbsd . | 5.1 - Creating the OpenBSD VM | 5.2 - Installing OpenBSD on the VM . | 5.2.1 - Booting the VM | 5.2.2 - Network and User Configuration | 5.2.3 - Hard Disk Configuration . | 5.2.3.1 - Root Disk and MBR Configuration | 5.2.3.2 - File System Configuration | . | 5.2.4 - Set Installation | . | 5.3 - Using OpenBSD . | 5.3.1 - Setting User Admin Privileges | 5.3.2 - Starting the X Window GUI | . | 5.4 - Deliverables | . | 6 - Installing Arch Linux . | 6.1 - Creating the Arch Linux VM | 6.2 - Installing Arch Linux on the VM . | 6.2.1 - Booting the VM | 6.2.2 - Network Configuration | 6.2.3 - Hard Disk Configuration . | 6.2.3.1 - Root Disk and MBR Configuration | 6.2.3.2 - File System Configuration | . | 6.2.4 - System Installation and Configuration . | 6.2.4.1 - Package Manager and Network Configuration | . | 6.2.5 - Bootloader Installation | . | 6.3 - Using Arch Linux . | 6.3.1 - Setting User Admin Privileges | 6.3.2 - Starting the X Window GUI | . | 6.4 - Deliverables | . | 7 - Quick Comparison of OpenBSD and Arch Linux | 8 - Installing Debian . | 8.1 - Creating the Debian VM . | 8.1.1 - VirtualBox | 8.1.2 - UTM | . | 8.2 - Using Debian . | 8.2.1 - Exploring Debian | 8.2.2 - Configure Host File Sharing . | 8.2.2.1 - VirtualBox | 8.2.2.2 - UTM | . | . | 8.3 - Deliverables | . | 9 - Submission | . ",
    "url": "/assignments/pa1.html",
    
    "relUrl": "/assignments/pa1.html"
  },"21": {
    "doc": "Programming Assignment 1",
    "title": "2 - Preliminary Steps",
    "content": ". | Make sure your host computer has enough disk space available. You will need about 60 GB of free disk space for installing Debian and completing future programming assignments. If you do not have enough disk space, you can delete some of your data, move it to a cloud, or consider purchasing an external drive to store your data. | Note: it is recommended that you not attempt to do coursework in an external drive, as the access times can hurt performance. | . | Make sure your host computer has a reliable internet connection before you begin, as you will be downloading quite a bit of data in this assignment. | You may need to reboot your host machine. Be prepared for this. | . ",
    "url": "/assignments/pa1.html#loc-2",
    
    "relUrl": "/assignments/pa1.html#loc-2"
  },"22": {
    "doc": "Programming Assignment 1",
    "title": "3 - OS-Specific Steps",
    "content": "windowsmacos 3.1 - Windows . VirtualBox is virtualization software (a type-2 hypervisor) you can install on your host machine to create and manage guest virtual machines running on top of your host OS. Before you install and use VirtualBox, first you need to make sure that Windowsâ€™ own Hyper-V VM software is disabled, otherwise it will conflict with VirtualBox, causing VirtualBox to fail or run in an extremely slow emulation mode. | Open Control Panel. | Select â€œPrograms and Featuresâ€. | Select â€œTurn Windows features on or offâ€. | Ensure the following features are unchecked if present in the list: . | â€œHyper-Vâ€ | â€œWindows Hypervisor Platformâ€ | â€œVirtual Machine Platformâ€ | . | Select â€œOKâ€ and reboot your computer if prompted. | Open Windows Security. | Select â€œDevice securityâ€ in the left column. | Select â€œCore isolation detailsâ€ link. | Ensure â€œMemory Integrityâ€ is turned off. | Leaving this on will force VirtualBox to run in emulation mode rather than the faster virtualization mode. | . | Reboot your computer if prompted. | . 3.2 - Macos . VirtualBox should work without issue on Intel-based Apple computers. If you have an Intel-based computer, skip this section. Since VirtualBox does not support x86 emulation on Apple Silicon, we will need to use UTM. Notes: . | VMWare Fusion Pro for Mac will work for subsequent programming assignments, but Parallels will not. | The virtualization software you use must allow you to select the kernel to boot at VM startup. (Multipass will not work) | . 3.2.1 - UTM . You can install UTM from the website or using homebrew: . brew install --cask utm . When using UTM, every time you create a new VM, you must do all of the following: . | Create the VM: . | Select an emulation VM, not a virtualization V, because you are going to install operating systems for amd64, not your native arm64 architecture. | Select â€œOtherâ€ when installing OpenBSD, or â€œLinuxâ€ when installing Arch or Debian. | Select the correct ISO file for the desired OS. | For â€œDisk Sizeâ€: . | OpenBSD: 6 GB | Arch: 6 GB | Debian: 60 GB | . | Continue VM creation using default values and select â€œSaveâ€. Do NOT start the new VM yet. | . | Configure VM Settings before installing an OS: . | Select the Settings icon in the upper right corner of the UTM window. | Under â€œSystemâ€: . | Under â€œCPUâ€: . | Select â€œEnables all features supported by the accelerator in the current host (max)â€. | If the above does not work, select â€œqemu64â€ (bottom of the list) | . | Enable â€œForce Multicoreâ€ | Ensure â€œCPU Coresâ€ matches your host system (see here) | . | Under â€œQEMUâ€: . | Disable â€œUEFI Bootâ€. (This assignment assumes VMs are using BIOS/MBR, rather than UEFI/GPT) | Enable â€œForce PS/2 controllerâ€. (required for the virtual keyboard to work correctly, especially on OpenBSD) | Enable â€œUse local time for base clockâ€. (especially for Arch Linux) | . | Under â€œInputâ€: . | Disable all USB options. (prevent conflict between PS/2 and USB virtual keyboards) | . | Under â€œDisplayâ€: . | Set â€œEmulated Display Cardâ€ to â€œVGAâ€ (Linux distros will have blank screen otherwise) | . | . | Save settings and start the VM. | . This process is not regularly tested, so please contact the instructor if you run into issues. ",
    "url": "/assignments/pa1.html#loc-3",
    
    "relUrl": "/assignments/pa1.html#loc-3"
  },"23": {
    "doc": "Programming Assignment 1",
    "title": "4 - Installing Virtualbox",
    "content": "This need only be done once. Skip this section if you are on Mac and have installed UTM. 4.1 - Virtualbox Application . If you already have VirtualBox v7.x installed, you may skip this section. You can use a package manager to install VirtualBox, or install it manually: . manualchoco . | Go to the VirtualBox download page. | Under â€œVirtualBox Platform Packagesâ€, download the correct version for your host platform and launch it. | Use all default options during install. | Ignore â€œMissing Dependencies Python Coreâ€ warnings. | . Chocolatey is a Windows package manager. Once installed, you can install VirtualBox using: . choco install virtualbox . 4.2 - Virtualbox Guest Additions . You will need to install guest additions on Debian later in this assignment. Download the VboxGuestAdditions_X.Y.Z.iso from the X.Y.Z/ folder at download.virtualbox.org. ",
    "url": "/assignments/pa1.html#loc-6",
    
    "relUrl": "/assignments/pa1.html#loc-6"
  },"24": {
    "doc": "Programming Assignment 1",
    "title": "5 - Installing Openbsd",
    "content": "OpenBSD is one of the members of the BSD family of Unix operating systems. It is interesting for you to install and use because: . | It has a text-based installation procedure that clearly shows all required steps without being too difficult to use. | OpenBSD is designed to be self-contained and work well â€œout of the boxâ€ with little extra software or configuration required. | It makes it easy to see the difference between . | the bootloader (the early time software that allows you to select which kernel to boot) | the kernel proper | the operating system services | the text-based console with a shell command line interpreter | the X Window graphical user interface | . | As a CS or CSE student, you should use a BSD system at least once in your life. Unix is more than just Linux! | . 5.1 - Creating the OpenBSD VM . | Download the ISO . | Visit the OpenBSD website. | Click the â€œDownloadâ€ link in the left column of the web page. | Download the ISO installXY.iso file (note the extension) for the â€œamd64â€ architecture. (this includes students on Apple Silicon) | . | Start VirtualBox and click the blue â€œNewâ€ button to create a new VM. | Give the name â€œcs492-openbsdâ€ to your new VM. | For the â€œISO imageâ€, select the installXY.iso file you just downloaded. | Under â€œHardwareâ€: . | Memory size: 4096 MB | Processors: max physical cores (green zone) (red zone indicates logical cores, which is irrelevent because OpenBSD disables hardware multithreading for security reasons.) | . | Under â€œHard Diskâ€: . | Virtual hard disk size: 6 GB | . | Hit â€œFinishâ€. | . At this point, you should have a VM with an empty 6GB virtual disk and a virtual CD containing the OpenBSD installation software. | Configure VM display: . | Select the orange â€œSettingsâ€ button in VirtualBox on the VM | Under â€œDisplayâ€: . | Change â€œGraphics Controllerâ€ to â€œVBoxSVGAâ€. (seems to work better with OpenBSD. ignore any warnings) | . | Under â€œStorageâ€: . | Select â€œControllerâ€ (with hard disk and CD as children): | Change â€œTypeâ€ to â€œAHCIâ€ | . | Hit â€œOKâ€ | . | . 5.2 - Installing OpenBSD on the VM . Remember to read each step before doing it! . 5.2.1 - Booting the VM . | Click the green â€œStartâ€ arrow to start your virtual machine. | The virtual machine will automatically boot from its virtual CD and start the installation software, which is a special copy of OpenBSD. | . | You should see a boot> prompt. This is the OpenBSD bootloader, which allows you to select the kernel you want to use. In this case, you can wait 5 seconds or hit Enter to allow the bootloader to automatically select a kernel. After the kernel is selected, for a brief time, you should see text with numbers. This is the bootloader copying the selected kernel from the virtual CD into VM memory. | When the background turns blue it means the kernel itself is running. The kernel will print a bunch of info to the screen describing the hardware it detects. | (VirtualBox-only) Enlarging the screen if needed: . | Click â€œViewâ€ in the windowâ€™s upper left corner | Click â€œVirtual Screen 1â€ | Select a scaling percentage (can be changed again later) | . | . 5.2.2 - Network and User Configuration . After the kernel has finished booting, the OpenBSD install script will begin automatically and you will be presented with the â€œInstall, Upgrade, Autoinstall, Shellâ€ prompt. This installation script has many steps. Most are trivial, though a few are complex. Most will also have a default option between square brackets ([]), which is usually (but not always) correct. If you make a mistake during the installation procedure, you can press Ctrl-C to abort the script and restart from the beginning by typing install at the # prompt. | Type I and hit Enter to begin the install script. For the first portion of the script, configure OpenBSD according to the table below. | Setting | Value | Comment | . | Keyboard Layout | Default (US/English) | | . | System Hostname | obsd | | . | Network Interface to Configure | Default (em0) | OpenBSDâ€™s name for the (virtual) hardware Ethernet nework controller | . | IPv4 Address | Default (autoconf) | OpenBSD will use the DHCP network protocol to automatically configure an IP address for the Ethernet network interface of the VM. The installation script will also configure the system to automatically use DHCP to get an IP address every time you reboot the VM. | . | IPv6 Address | Default (none) | | . | Network Interface | Default (done) | | . | root Password | obsd | Note: on many Unix systems, passwords will not appear on-screen when typed in a shell. | . | Start sshd | no | Note: we do not want anyone using ssh to login to the VM. | . | Run X Window | Default (yes) | | . | Use xenodm | Default (no) | Note: you will learn how to start the X Window GUI manually later. | . | Setup User | Stevens login name | e.g. rtsang1 from rtsang1@stevens.edu. | . | Full Name | Your full name | | . | Password | obsd | Your user account password. | . | Time Zone | Default (EST) | Note: you can input ? for a list of available time zones. | . | . 5.2.3 - Hard Disk Configuration . At this point, you should be at hard disk configuration. A single hard disk can be divided into multiple â€œprimary partitionsâ€, with each partition storing a different operating system (sort of). For example, one primary partition could store Windows while another stores OpenBSD, and the OS to run could be chosen at boot-time using the bootloader. This is called multi-booting. In this stage we will first configure the Master Boot Record (MBR), which stores the number of primary partitions, their type, and their size, in the first sector (data block) of the hard disk. Then we will configure at least one file system. For simplicity, we will use a single primary partition occupying the entire virtual hard disk that has a single FFS file system for the root directory. Inside each primary partition, multiple file systems can be created for the same OS (if the OS supports it). For example, one OpenBSD FFS file system for the / root directory, and another FFS for the /home user home directories can be created in the same primary partition. Linux also supports multiple file systems in a partition, but uses ext4, but also supports ext2 and btrfs among others. By contrast, Windows only has one NTFS file system per primary partition (e.g. C: and D: drives). 5.2.3.1 - Root Disk and MBR Configuration . | Configure the root disk and MBR as follows: . | Setting | Value | Comment | . | root Disk | sd0 | To see a full list of available hard disks in the VM, type ? and hit Enter. sd0 should be the only option, with the name â€œVBOX HARDISKâ€ (or â€œQEMU HARDISKâ€ for Apple users on UTM), and a size of 6 GB. This is the hard disk where the OpenBSD primary partition and root filesystem will be created. | . | root Disk Encryption | Default (no) | This option encrypts the entire hard disk, which would affect performance if selected. | . | Whole disk MBR/GPT | Default (whole) | Since the disk is still empty, it does not yet have a Master Boot Record. When you select whole, the installation script will create a single primary partition using fdisk that will occupy the entirety of the virtual hard disk. Then it will create a new MBR for the partition. | . Note that the primary partition does not start in disk sector 2 (which immediately follows the MBR). Some empty disk space must be left between the MBR and the start of the partition to store the OpenBSD bootloader. fdisk automatically accounts for this. GPT is a more recent and more advanced version of the same kind of partition table that allows you to create more than 4 primary partitions. MBR with up to 4 partitions is plenty for us. | . 5.2.3.2 - File System Configuration . Now we need to create a single / root file system (rfs) in our primary partition. The install script automatically offers a default configuration of file systems, with a root file system in addition to /usr, /home, and â€œswapâ€ file systems. (swap is used for memory management and will be revisited later in the course) . Since this is not what we want, we will configure our file system manually. | Start the custom file system configuration by entering c into the prompt. This will start OpenBSDâ€™s disklabel interactive editor, and a new prompt (sd0> ) will appear. In this mode you will be able to specify the number of file systems to create, along with their location, size, type, and directory path (e.g. /, /usr, /home). You can enter ? into the prompt to get a list of available commands. | Enter a to add a new file system with the following configurations: . | Setting | Value | Comment | . | Partition | Default (a) | File system â€œaâ€ on disk â€œsd0â€ will have a full name â€œsd0aâ€. Note that OpenBSD uses the word â€œpartitionâ€ in place of â€œfile systemâ€ for historical reasons. | . | Offset | Default | The offset indicates the hard disk sector number where the start of the file system will be placed in the primary partition. Do not try to change this unless you know how the file system is organized in the primary partition. | . | Size | Default | Size of the file system in number of disk sectors. The default value corresponds to the size of the entire primary partition. A different size (e.g. â€œ3Gâ€) could be specified to leave room for another file system. | . | FS Type | Default (4.2BSD) | Standard file system type for BSD systems (also called â€œFFSâ€ or â€œUFSâ€). | . | Mount point | / | Mount the file system at the root directory. | . | When the prompt returns (sd0*> ), you can enter p to show the current state. You should see the a file system, and the unused c file system, which represents the whole primary partition. The * in the prompt indicates that the changes are pending; disklabel has not yet changed anything on the hard disk (much like git staging before commits). | When you are ready to commit changes to the disk, enter w, then q to quit disklabel. After quitting, the root file system should be initialized automatically, and you will see logs about /dev/sd0a. Note that this new file system is mounted at /mnt, not /. This is because the virtual CD was mounted at / on boot, and the installer program is currently using it. /mnt is a temporary mount point and the newly configured file system will be mounted at / the next time the VM boots from the virtual hard disk. | . 5.2.4 - Set Installation . â€œInstalling the setsâ€ refers to copying the OpenBSD operating system files (kernel, system utilities, man pages, GUI, etc.) to the root file system. | Install the sets according to the table below: . | Setting | Value | Comment | . | Location of sets | cd0 | The virtual CD (located at cd0) includes all the required file sets (file packages). | . | Pathname to sets | Default (X.Y/amd64) | This is the path on the CD to the location of the file sets. | . | Set names | Default (all, done) | . | bsd: kernel for mono-processor machines | bsd.mp: kernel for multiprocessor machines (installer will select right kernel automatically based on detected number of cores) | bsd.rd: special kernel for installation (currently in use) | baseXY.tgz: basic utilities (ls, etc.) | compXY.tgz: C compiler and C headers | manXY.tgz: manual pages | x*.tgz: X Window GUI files | . | . | Continue without verification | yes | The warning about missing SHA256.sig is normal for CD-based installation files, since adding a cryptographic signature file to the ISO file would alter the resulting fileâ€™s signature. | . | (Maybe) Location of sets | Default (done) | After the file sets are copied you may be prompted to install more software. We do not need to. | . | If you get a warning that says â€œTime appears wrongâ€, hit Enter and continue. | At this point, the installation script will automatially create special files in the /dev directory of your new system to access the (virtual) hardware (â€œmaking all device nodesâ€¦â€). It will select the correct kernel (â€œusing bsd.mp instead of bsdâ€). It may apply a firmware update if needed (fw_update). Firmware is a separate bit of software that runs directly on a hardware device components, like the disk controller or network controller. Firmware is not part of OpenBSD and is usually hardware-specific. OpenBSD wil â€œre-linkâ€ (randomize) kernel code locations for security reasons (think ASLR). Finally, the script will silently install the OpenBSD bootloader on the hard disk between the MBR and the start of the primary partition. The bootloader is necessary so that the VM can locate and load the OpenBSD kernel. | Enter h to halt. Wait until you see â€œPlease press any key to rebootâ€, then close the window. Do not use the default (reboot) option! . VirtualBox: Select â€œPower off the machineâ€ in the prompt. The virtual installation CD needs to be ejected before we reboot the VM. | Eject the installation CD. virtualboxutm In VirtualBox: . | Open the VMâ€™s settings. | Under â€œStorageâ€: . | Select the installXY.iso CD file. | Select the blue CD icon to the right of the â€œOptical Driveâ€ menu. | Select â€œRemove Disk from Virtual Driveâ€ to simulate ejecting the installation CD. | Click â€œOKâ€. | . | . In UTM: . | Stop the VM if itâ€™s status is â€œSuspendedâ€ (â€œStopâ€ button in upper right corner). | Open the VMâ€™s settings by right-clicking on the VM and selecting â€œEditâ€. | Select the â€œIDE Driveâ€ that corresponds to the installXY.iso file. | Select â€œClearâ€ next to the â€œPathâ€ entry to remove the file from the virtual CD drive. | . | . 5.3 - Using OpenBSD . After starting the VM, you should see a similar sequence of steps. The boot>&#x20; prompt will appear for 5 seconds before copying the kernel into main memory. The text background will turn blue while the kernel is running. The difference this time is that the VM is booting from its own disk rather than the installation CD. After the kernel finishes booting, the system services will start, showing messages with a black background again. Some things you might see: . | syslogd: the OS message loggin service | ntpd: the system time service | smtpd: the systemâ€™s local email service | sndiod: system sound service | . All these services are part of the OpenBSD operating system, but they run as separate user-mode processes outside the kernel. 5.3.1 - Setting User Admin Privileges . | Login as root, use obsd password. This will get you a ksh shell by default with a prompt obsd#&#x20; (the system name followed by # to indicate admin user instead of the normal $). | Give your user account (your Stevens login name) admin privileges: . | cd /etc ; ls. Most OpenBSD system config files live here. | cp examples/doas.conf .. Create a doas.conf config file for the doas command (like sudo in Linux). The example config will automatically allow any user in the wheel user group to run commands as administrator. You can view the contents of the file with cat doas.conf. | Add your user account to the wheel group. Luckily, users created during the installation process are automatically added to the wheel group. You can check who is in the wheel group with grep using the command grep wheel /etc/group. | exit to exit the shell and return to the login prompt. | . | . 5.3.2 - Starting the X Window GUI . The text-based screen, or text user interface (TUI), where your shell runs is called the virtual console. OpenBSD (and Linux) have multiple virtual consoles available, but these are not always the most convenient. Instead, we will manually start the X Window GUI. | Login with your Stevens username (e.g. rtsang1) and obsd as your password. You will be logged in to your user home directory. Use pwd to see the current directory path, and ls -la to see a detailed list of files in the current directory. | Run doas xenodm to manually start the X Window GUI. Enter your the root password (obsd) and you should see the GUI. OpenBSD users do not usually need to use admin privileges with doas to start the X Window Gui, but it is required here because the VM has a very basic virtual graphics card. The default OpenBSD GUI is quite ugly. The bare X Window system minimally handles: . | the mouse | the keyboard | the computer screen | the FVWM window manager (allows you to have menus; create, move, and resize windows; etc.) | . OpenBSD has better GUIs available (e.g. KDE) but the bare GUI is enough for this assignment. | . 5.4 - Deliverables . To prove you have installed and used OpenBSD successfully, you will submit a screenshot showing the OpenBSD kernel version and the output of the id command. | Enlarge the text in the xterm terminal window. | Hold Ctrl+Right-Click in the center of the xterm window to see text size options and select â€œHugeâ€. | . | Run the following commands: . | uname -a to show OpenBSD kernel version. | id to show username and user groups. | . | Take a screenshot of the OpenBSD screen. You can use VirtualBoxâ€™s built-in option View -> Take Screenshot, or your host OS screenshot tools. An example can be seen in Figure FigureÂ 1. FigureÂ 1: OpenBSD Deliverable Example | Once you have a screenshot, you can shut down OpenBSD by running doas halt -p in the xterm window and enter the root password. This will halt the virtual machine (-p means powerdown), save files to the hard disk (â€œsynching disksâ€¦doneâ€), then power down the VM. | After powerdown, you can delete the entire VM as it will not be used again in this course. You can also delete the installXY.iso file. Congratulations on using OpenBSD! . | . ",
    "url": "/assignments/pa1.html#loc-9",
    
    "relUrl": "/assignments/pa1.html#loc-9"
  },"25": {
    "doc": "Programming Assignment 1",
    "title": "6 - Installing Arch Linux",
    "content": "Arch Linux is interesting for you to install and use because: . | It has a text-based installation procedure which is even more minimalist than the OpenBSD one. While an installation script exists, it does not configure Linux as we would like, so we will be installing everything command by command. | It will show you that not all Linux distributions have GUI-based install procedures like Ubuntu or Debian. This is an opportunity to get comfortable in the command line if you havenâ€™t done so already. | . 6.1 - Creating the Arch Linux VM . | Download Arch Linux: . | Go to the Arch Linux website and navigate to the â€œDownloadâ€ page. | On the â€œDownloadâ€ page, go to the â€œWorldwideâ€ section, and click the first mirror link available. | Download the archlinux-x86_64.iso file. | . | Create a new VM in VirtualBox or UTM: . | Give the name â€œcs492-archlinuxâ€ to your new VM. | For the â€œISO imageâ€, select the archlinux-x86_64.iso file you just downloaded. | Under â€œHardwareâ€: . | Memory Size: 4096 MB | Processors: max physical cores | . | Under â€œHard Diskâ€: . | Virtual hard disk size: 6 GB | . | . | (Apple UTM Users) Under â€œDisplayâ€ in VM settings, change the â€œEmulated Display Cardâ€ to â€œVGAâ€, or you may see a blank screen when you try to install Arch. | . At this point, you should have a virtual machine with an empty 6 GB virtual disk, and a virtual CD containing the Arch Linux installation software. 6.2 - Installing Arch Linux on the VM . Remember to read each step carefully before doing it! . 6.2.1 - Booting the VM . | Start your virtual machine. The VM will automatically boot from its virtual CD and start running the installation software, a special copy of Arch. Similar to OpenBSD, you should see a menu come up. This is Archâ€™s installation bootloader, which will allow you to select the kernel to use, and will automatically select a kernel after 15 seconds. Once the kernel is selected, it will start. In Linux, kernel messages should show a timestamp at the beginning of the line. This may be blank (::) in the VM. As the kernel starts, systemd will start. systemd is a part of the Arch operating system, outside the kernel, that automatically starts various system services. It will show logging messages that start with a green [OK] if the corresponding service started successfully. After the kernel finishes booting, you will get a shell with the prompt root@archiso ~ # . This is normal, since Arch doesnâ€™t have an installation script by default. Instead, you will now install Arch manually by executing the commands one by one. Note: â€œrootâ€ is the system administrator, â€œarchisoâ€ means you are running from the ISO-formatted installation CD, â€œÂ â€œ means you are currently in rootâ€™s home directory, and â€œ#â€ is the traditional shell prompt when you are root. | If the text is too small in the terminal, run the command setfont -d to double the font size on the screen. Run setfont without flags to reset the font size. | . 6.2.2 - Network Configuration . | Arch should have automatically connected to the Internet via the VMâ€™s Ethernet network interface. To verify this, execute ping archlinux.org. If the network is set up correctly, you should see ping responses (it may take a while to run on UTM due to emulation). Stop ping with Ctrl-C. | . 6.2.3 - Hard Disk Configuration . As with OpenBSD, we need to create a primary partition for Arch and a Linux file system inside this primary partition. However, where OpenBSD automated some of this process for us, we will need to use the fdisk utility ourselves to do so. 6.2.3.1 - Root Disk and MBR Configuration . | List hard disk names with fdisk -l. Ignore /dev/loop disks, as these are fake disks used by Linux internally. You should see a /dev/sda disk with a size of 6 GiB, with the name â€œVBOX HARDISKâ€ (or â€œQEMU HARDISKâ€ on UTM). We will create the primary partition here. | Execute fdisk /dev/sda to begin an interactive editing session with the /dev/sda disk. | Enter m to see a list of fdisk commands. Commands are generally all single letters. | Enter p to see the current list of primary partitions on the VM disk. Currently, it should show general disk information but list no primary partitions. | Enter n to create a new primary partition with the following configuration: . | Setting | Value | Comment | . | Partition Type | Default (p) | We have not discussed extended partitions yet and will stick with primary partitions. | . | Partition Number | Default (1) | Recall that MBR supports up to 4 primary partitions. Using 1 will create the partition /dev/sda1. | . | First Sector | Default (2048) | This indicates the hard disk sector number where the start of the primary partition will be. Note again that we will leave some free space left between the MBR (first sector) and the start of the primary partition for the bootloader. Donâ€™t modify this value unless you know very well what you are doing. | . | Last Sector | Default (a large number) | The last sector of the primary partition. The difference between the first and last sector numbers plus 1 will give the total size of the new partition, which will be the entire disk size here. | . | Enter p to see the list of primary partitions (not yet committed). You should see the device /dev/sda1 with the start and end sector numbers used, and the type â€œLinuxâ€. There is a separate fdisk command to create a Windows or OpenBSD primary partition. | If you made a mistake, you can delete the staged partition using d to start over. Once you are sure things are set up correctly, you can commit the changes to disk by entering w. This will also return you to the root shell. | . | . 6.2.3.2 - File System Configuration . Linux uses exactly one file system per primary partition (like Windows), so the â€œdisk labelâ€ process in OpenBSD is unnecessary. | Create a new file system in /dev/sda1 by runing mkfs.ext4 /dev/sda1. This creates a new ext4 file system in /dev/sda1 that spans the entire primary partition. The output of mkfs.ext4 will print information referencing â€œinodesâ€ and â€œsuperblockâ€, which we will cover later in the semester. | Mount the new file system to an existing directory by running mount /dev/sda1 /mnt. On OpenBSD, the new file system you created was automatically mounted for you on /mnt by the installation script. On Arch, you need to do this yourself. Right now, the kernel you are using is the one you booted from the CD, and the / root file system is the one from the CD (for simplicityâ€™s sake). The command you ran will temporarily mount the file system in the /dev/sda1 partition in the /mnt directory so you can actually modify it during the rest of the installation procedure. | Running mount again will show all currently mounted file systems. At the end of the output, you should see the primary partition /dev/sda1 ext4 file system mounted in /mnt. | Execute ls -l /mnt to check that the new file system is empty, except for a â€œlost+foundâ€ directory, which can be ignored. | . 6.2.4 - System Installation and Configuration . | Once the file system is mounted, you can copy the file sets for Arch to the new file system. | File sets for Arch are available as packages from servers on the Internet. Run reflector to configure the closest servers for downloading file sets. | Run pacstrap -K /mnt base linux linux-firmware. It may take a while. The pacstrap package manager will download the base package for cli utilities, linux package for the Arck kernel, and the linux-firmware package for updating hardware device controller firmware. All of these will be installed the the /mnt directory as a minimal Arch system. | . | Execute genfstab -U /mnt >> /mnt/etc/fstab to generate a new /etc/fstab file in the file system, which Arch will use later when booting to know determine the file system to use. Note: the >> means â€œappend program stdout to the end of the fileâ€, while a single > will overwrite the file. | Execute cat /mnt/etc/fstab to see the content of the new file. You should see that your /dev/sda1 primary partition will be the root file system once you boot Arch from the VMâ€™s hard disk. | Switch to the new file system root by running arch-chroot /mnt. This will cause / to be located at /mnt, and the shell prompt will change from root@archiso ~ #&#x20; to [root@archiso /]# . | Execute ls to list the contents of the root directory in the new file system. You should see all the root-level Unix directories. | Configure date and time: . | Execute date and confirm that the VM is currently configured to use the default UTC time zone. | Execute ln -sf /usr/share/zoneinfo/EST /etc/localtime. This will specify the correct time zone by creating a symlink to point at the right time zone. | Execute date again and confirm the date and time are correct. | . | Name the VM system . | Run cat > /etc/hostname. The cat program will wait for input on stdin. | Type in arch and hit Enter, then press Ctrl-d to quit to the shell. | Execute cat /etc/hostname to see the content of the new /etc/hostname file, and you should see arch on a single line. | . | Execute passwd to set the password for the root user. Use arch as the password. This will be a blind input, which you will input type twice. | . 6.2.4.1 - Package Manager and Network Configuration . | Execute pacman -S reflector to install reflector. We will use reflector to configure the new Arch system with the correct package servers. The reflector program we used before was from the CD, and is not yet available in the new file system. The pacman program is Archâ€™s standard package manager. You can use it to download and install thousands of different software packages, similar to pkg_add on OpenBSD and apt on Debian-based systems. | Execute reflector again to configure the new Arch system with package servers. | Execute pacman -S dhcpcd to install a DHCP client, otherwise the system will not be able to get an IP address and connect to the Internet when we boot from the hard disk later. | Find the VMâ€™s network interface by running ip addr. You should see a network name like â€œenp0s1â€, ignore loopback interfaces. Remember this name, as we will use it to configure systemd to automatically start the dhcpcd client at boot time. dhcpcd will automatically get an IP address for the VMâ€™s Ethernet network interface to allow the VM to connect to the internet. | Configure systemd to start the dhcpcd client with your network name by running systemctl enable dhcpcd@&lt;network-name>.service. For example, with â€œenp0s1â€, it would be systemctl enable dhcpcd@enp0s1.service. | Execute systemctl enable systemd-resolved.service to configure the DNS resolver, which translates computer names to IP addresses for you. The OpenBSD installation script performed this network configuration for you. | . 6.2.5 - Bootloader Installation . The last step is to install a bootloader, which will load the kernel into memory at boot time. The standard bootloader for Linux is GRUB. | Download GRUB: pacman -S grub. | Install GRUB: grub-install --target=i386-pc /dev/sda. This installs GRUB after the master boot record and before the primary partition. | Generate the /boot/grub/grub.cfg configuration file for GRUB: grub-mkconfig -o /boot/grub/grub.cfg. This tells GRUB which menu entries to offer to the user when booting the VM. You can execute cat /boot/grub/grub.cfg to see the content of GRUBâ€™s configuration file. Itâ€™s ugly. | Run exit to go back to the / root file system of the installation CD, then depending on your system, do the following: . windowsmacos Before you shut down the VM, go the the â€œDevicesâ€ menu of the VirtualBox window. Under â€œOptical drivesâ€, select â€œRemove disk from virtual driveâ€. Click â€œForce Unmountâ€ if necessary. Then execute shutdown now to stop the VM. Execute shutdown now to stop the VM. Once the system has shut down, close the window and open UTM settings for the VM. Under â€œIDE Driveâ€, select the virtual installation CD (archlinux-x86_64.iso), then select â€œDelete Driveâ€. | . 6.3 - Using Arch Linux . We will now create a user account and, like OpenBSD, need to give our user account admin privileges. 6.3.1 - Setting User Admin Privileges . | Start the Arch Linux VM. You should see a similar process as before, where the GRUB boot loader will copy the selected kernel to memory. After the kernel finishes booting, systemd will start and initialize all system services quietly. | Login as user root with password arch and configure a new user account: . | You will be logged in to a bash shell, where you can run ls -la to see the files in rootâ€™s home directory. | Execute setfont -d to double the font size if needed. | Create a new user (replace with your name and Stevens login): useradd -c 'Ryan Tsang' -m rtsang1. | Configure the user password, using arch as the password: passwd rtsang1. | Add your account to the wheel group: gpasswd -a rtsang1 wheel. | Install sudo: pacman -S sudo. | Install vi: pacman -S vi. | Configure sudo to allow all users in the â€œwheelâ€ group to run commands as root: . | Edit the /etc/sudoers file: visudo. | In vi, type :125 and hit Enter to jump to line 125 in the file. This should be the first line that starts with # %wheel. | Uncomment the line (\\# is a line comment) by typing x with the cursor highlighting the character. Do this again to delete the space as well. The line should now start with %wheel, which will allow all users in the wheel group to execute commands as admin. | Type :wq and hit Enter to write the disk to file and quit vi. | . | Run exit to return to the login prompt. | . | . 6.3.2 - Starting the X Window GUI . As we did for OpenBSD, we will be manually installing the X Window GUI. | Login with your Stevens username using password arch. Run pwd to see where the current directory is located, and ls -la to show a detailed list of the current directoryâ€™s contents. | Install the X Window system as root: . sudo pacman -S xorg xorg-xinit xterm xorg-fonts-misc xorg-fonts-type1 . This will install the X Window system itself (xorg), xterm, and some fonts. | Install the Ice Window Manager: . sudo pacman -S icewm . | Configure X Window to use IceWM as its window manager by creating a file named .xinitrc in your home directory with the name of the window manager to use: . echo \"icewm\" > .xinitrc . Note the â€œ.â€ at the beginning of the filename. This is common for configuration files in Unix. If you run cat .xinitrc, you should see only â€œicewmâ€ appear on the console output. | Run startx to start X Window. | . 6.4 - Deliverables . To prove you have installed and used Arch successfully, you will submit a screenshot showing the Arch Linux kernel version and the output of the id command. | Enlarge the text in the xterm terminal window. | Hold Ctrl+Right-Click in the center of the xterm window to see text size options and select â€œHugeâ€. | . | Run the following commands: . | uname -a to show Arch Linux kernel version. | id to show username and user groups. | . | Take a screenshot of the Arch screen. You can use VirtualBoxâ€™s built-in option View -> Take Screenshot, or your host OS screenshot tools. An example can be seen in Figure FigureÂ 2. FigureÂ 2: Arch Linux Deliverable Example | Once you have a screenshot, you can shut down Arch by running sudo shutdown now in the xterm window and enter the root password. | After powerdown, you can delete the entire VM as it will not be used again in this course. You can also delete the ISO file. Congratulations on using Arch! . | . ",
    "url": "/assignments/pa1.html#loc-22",
    
    "relUrl": "/assignments/pa1.html#loc-22"
  },"26": {
    "doc": "Programming Assignment 1",
    "title": "7 - Quick Comparison of OpenBSD and Arch Linux",
    "content": "If you compare te way you installed these two operating systems, the whole procedure is largely the same: . | Download and boot a special version of the OS from a CD (or USB thumb drive) | Create a primary partition on the hard disk | Create a file system inside the primary partition | Copy and install all the necessary files for the new OS from the CD or Internet | Install a bootloader, which will start the kernel on boot | Configure various settings, such as network interface, users, time zone, and other software. | . There are a few notable observations: . | OpenBSD normally uses only one primary partition, which can contain multiple file systems. Arch Linux, and Linux systems in general, as well as Windows, can use mulitiple primary partitions, with a single file system on each partition. In practice, the result is generally the same: you can have multiple file systems for various purposes (e.g. / for root, /home for users, etc.) . | OpenBSD has a nice, but terse, installation script that does many things for you. Arch also has an installation script, but we did things manually here. | Both operating systems have many shared utility programs (ls, pwd, cd, fdisk, etc.) but some are different (doas vs. sudo, pkg_add vs. pacman). | Both operating systems use the same X Window GUI, which is quite basic, but is the standard GUI for Unix systems. On top of X Window, you can install a nicer looking â€œdesktop environmentâ€, such as GNOME, KDE, Xfce, or any number of others. | . ",
    "url": "/assignments/pa1.html#loc-37",
    
    "relUrl": "/assignments/pa1.html#loc-37"
  },"27": {
    "doc": "Programming Assignment 1",
    "title": "8 - Installing Debian",
    "content": "Now we will install Debian, which we will be using for the rest of th semester. If you have used Ubuntu before, it will feel very similar, as Ubuntu is based on Debian, and uses the same underlying package manager, apt. Debian is just as easy to use, but ships with less software and automatically shows the GRUB bootloader at boot time, which you will need to use in later assignments to boot your own Linux kernel. 8.1 - Creating the Debian VM . | Download Debian . | Visit the Debian homepage and ignore the â€œDownloadâ€ button. Visit the â€œOther downloadsâ€ link instead. | Navigate to the section â€œDownload an installation imageâ€ and visit the â€œsmall installation imageâ€ link. | Navigate to the section â€œSmall CDs or USB sticksâ€ and download the â€œamd64â€ option. | . | . From here, install instructions are different for VirtualBox and UTM. virtualboxutm 8.1.1 - VirtualBox . | Create a new VM: . | Give the name â€œcs492-debianâ€ to the VM. | For â€œISO imageâ€, select debian-X.Y.Z-amd64-netinst.iso. Leave â€œSkip Unattended Installationâ€ box unchecked. | Select the â€œUnattended Installâ€ option and use the following configurations: . | Setting | Value | Comment | . | Username | Stevens username (e.g. rtsang1) | | . | Password | debian | | . | Hostname | debian | | . | Domain Name | Default | | . | Guest Additions | Yes | Use the VBoxGuestAdditions_X.Y.Z.iso file you downloaded previously. | . | Memory | Maximum recommended | Use the limit of the memory green zone | . | Processors | Maximum recommended | Use the limit of the cpu green zone. You will need the power when you manually compile the linux kernel in the next assignment. | . | Virtual Hard Disk Size | 60 GB | The OS alone requires at least 6 GB, rounded up to 20 GB for additional software, such as VS Code, another 20 GB for a â€œworkingâ€ copy of the Linux kernel source code, and another 20 GB for a backup of compiled kernel code. The backup will be needed if you bork the working copy in programming assignment 2, as saving compiled artifacts in a known good state will reduce compile time if you need to nuke your working copy. | . | . | . VirtualBox will create the VM with an empty 60 GB hard disk and virtual CD, then automatically boot the VM and run the install process automatically. If you watch carefully, you should see the following: . | The VM boots the Linux kernel | DHCP will configure the VMâ€™s enp0s3 Ethernet network interface to connect to the internet | A partitioning tool will create a primary partition with a new file system | The base Debian system will be installed to the file system and configured | Many extra software packages will be installed (e.g. Python, LibreOffice, etc.) | GRUB will be installed | More configuration and cleanup | Once the system is ready, the install CD will be automatically ejected and the VM will reboot. | VM boots from hard disk | GRUB bootloader starts | Linux kernel starts | systemd starts | Login prompt displays in the default GNOME desktop environment, which uses the Wayland compositor instead of X Window. | . 8.1.2 - UTM . Unlike VirtualBox, UTM cannot automatically install Debian, and you will need to use Debianâ€™s installation GUI, which is very similar to setting up Ubuntu. | Create a VM with the name cs492-debian and 60 GB disk size. Refer to SectionÂ 3.2.1. | In the VM settings, change the CPU to â€œqemu64â€ (end of the list). | Start the VM. | Install Debian using the default â€œGraphical installâ€ option with the following configuration: . | Setting | Value | Comment | . | Language | Default (English) | | . | Location | Default (United States) | | . | Keyboard | Default (American English) | | . | Hostname | debian | | . | Domain name | Default (none) | | . | Root password | debian | | . | Full Name | Your name | | . | Username | Your Stevens login (e.g. rtsang1) | | . | Password | debian | | . | Time Zone | Default (Eastern) | | . | Partitioning Method | Default (Guided - use entire disk) | | . | Partitioning Scheme | Default (All files in one partiton) | | . | Write changes to disk? | Yes | | . | Scan extra installation media? | Default (No) | | . | Debian archive mirror country | Default (United States) | | . | Debian archive mirror | Default (deb.debian.org) | | . | HTTP proxy information | Default (none) | | . | Pacticipate in package usage survey | Default (No) | | . | Choose software to install | Default | | . | Install GRUB to your primary drive? | Default (Yes) | | . | Device for bootloader installation | /dev/sda | | . | Remove the virtual installation CD. | . 8.2 - Using Debian . | Start the VM and log in with your debian password. | Skip your way through the â€œWelcomeâ€ windows. | If you do not see a toolbar at the bottom of the window, click the â€œActivitiesâ€ menu in the top left corner. You should now see a toolbar with various applications that come preinstalled on Debian. We will not use these for the course. | Select the 3x3 grid of dots to see more applications, and find the â€œTerminalâ€ application. Right-Click â€œTerminalâ€ and select â€œPin to Dashâ€, which will add the application to the toolbar. Then open the â€œTerminalâ€ application. | Execute ls -la to list the files in your home directory, and pwd to print the path to your home directory. | Give yourself administrative privileges to use sudo: . | Switch to the root user account by running su - (which means â€œsubstitute userâ€ and historically, â€œsuperuserâ€). You will need to login using the root credentials, debian. | As root, add your user account to the sudo group (unlike OpenBSD and Arch, which use the wheel group): . usermod -aG sudo rtsang1 . | Run exit to return to the user shell and restart Debian. | Click the battery icon in the upper right corner of the desktop. | Click the power icon and select â€œRestartâ€ and confirm. | . | Log back in for you changes to take effect. | . | . 8.2.1 - Exploring Debian . | Run the following commands to have a look around your Debian VM . | sudo fdisk -l . This should show the VMâ€™s disk is named /dev/sda and that it has a /dev/sda1 â€œLinuxâ€ bootable primary partition, inidcated by a * in the output. There is also a /dev/sda5 swap partition, which is used by the kernelâ€™s virtual memory system, as we will see later in the semester. Note also that although the MBR partition system only allows 5 primary partitions, the swap partition has index 5. This is because the swap partition is not a primary partition, but an extended partition, which itself is in the /dev/sda2 primary partion, set up to support extended partitions. This is why /dev/sda2 and /dev/sda5 have about the same start sector and size. | cat /etc/fstab . This will show your / root file system is of type ext4. You can also see the swap extended partition if of the special type â€œswapâ€, meaning it does not contain a file system. | mount . This will show that the /dev/sda1 ext4 primary partition is mounted at /. | df -h . This will show a usage summary for various file systems. /dev/sda1 should currently be using about 5 GB, with another 50GB or so available. | ls /boot . This is where your linux kernel is stored. You can also find there the â€œgrubâ€ directory that contains the grub.cfg configuration file for the GRUB bootloader. | which gcc . This will print /usr/bin/gcc if C compiler is already installed. If it is not, you can install it and other C development packages by running: . sudo apt install build-essential . The which command is used to find where different programs are installed on your system if they are in your current PATH. Try doing the same with the vi text editor, the make build system, the python3 interpreter, and the firefox web browser. You can see a long list of default installed programs by running ls /usr/bin. | . | Installing software . | Use the apt package manager to install software on Debian, for example, emacs: sudo apt install emacs-nox . | You can search for available packages in the debian package repository. | . | To shut down the VM, execute sudo shutdown now in a terminal window, or user the GUI option. Shut down your VM now. Note: Never shut down the VM by closing the window in your host machine! Doing so can corrupt the virtual file system in the VM, and while the file system is capable of some self-repair, it is not advisable to rely on it. Only do so if the VM is truly frozen or unresponsive. | . 8.2.2 - Configure Host File Sharing . virtualboxutm 8.2.2.1 - VirtualBox . | In the â€œGeneralâ€ menu, under â€œAdvancedâ€, change both â€œShared Clipboardâ€ and â€œDragâ€™nâ€™Dropâ€ to be â€œbidiractionalâ€. This will allow you to copy and paste between Debian and your host OS. | Set up a shared directory with the host: . | On you host OS, create a new folder named â€œsharedâ€ anywhere you like. | In the VirtualBox VM â€œSettingsâ€, select â€œShared foldersâ€. | Add a new shared folder by selecting the green â€œ+â€ icon and configure as follows: . | Setting | Value | Comment | . | Folder Path | shared | Use the â€œsharedâ€ folder you just created | . | Folder Name | shared | | . | Mount point | /mnt/shared | This will be the location of the shared folder in Debian. | . | Auto-mount | Yes | This will make sharing happen automatically when the VM starts. | . | . | Start the VM, log in, and open Terminal. | Execute ls /mnt/shared to confirm you can see the content of the shared folder on your host. | In your home directory, run ln -s /mnt/shared shared, then confirm the symlink works by running ls shared. You should see the content of the shared folder. | . 8.2.2.2 - UTM . You have options on UTM, though both have their downsides. You can use SPICE WebDAV, which has an easier setup, or VirtFS, which will have better performance. The instructions here are for setting up shared folders via VirtFS: . | Create a folder named shared on your host OS, wherever you like. | Before launching the VM, configure the VM to use VirtFS for sharing: . | Open VM settings and go to â€œSharingâ€ | Ensure â€œEnable Clipboard Sharingâ€ is checked | Select â€œVirtFSâ€ for â€œDirectory Share Modeâ€ | Select the path to the shared directory you created | . | Launch the VM and open Terminal . | Add the shared folder to the file system table (fstab): . | Run sudo vi /etc/fstab to edit the fstab file with vi. | The following commands are case sensitive: . | Type G to go the start of the last line of the file. | Type o to insert a new line below the current line and enter Insert mode. | Add the following lines to the file: . # UTM Shared Foldershare /mnt/shared 9p trans=virtio,version=9p2000.L,rw,_netdev,nofail,auto 0 0 . | Type Esc to leave Insert mode. | Type :wq to write the changes to file and quit vi. | . | . | To avoid permissions issues, we will use bindfs to then mount the /mnt/shared folder to a folder in our user home directory. | Install bindfs: sudo apt install bindfs . | We will likely need to map the user and group ids of files in /mnt/shared, so we need to find out the user and group IDs of the guest and host machines. | In Debian, run id and find the user ID (UID) and group ID (GID). By default, these are typically both 1000. | In a host terminal, run id and do the same. | Now add the following lines to the fstab, following the same general procedure as above, and replacing bracketed fields (e.g. &lt;guest_uid>) as needed: . # bindfs mount to remap UID/GID/mnt/shared /home/&lt;username>/shared fuse.bindfs map=&lt;host_uid>/&lt;guest_uid>:@&lt;host_gid>/@&lt;guest_gid>,x-systemd.require=/mnt/shared,_netdev,nofail,auto 0 0 . | . | Restart the VM by running sudo reboot . | Test the shared directory: . | In your host OS, create a test file named test.txt in the shared directory you created. | In Debian, edit it by running echo \"testing\" >> shared/test.txt. | In your host OS, check that the change appears by running cat test.txt from a terminal in your host. | . | . 8.3 - Deliverables . To prove you have installed and used Debian successfully, you will submit a screenshot showing the Debian kernel version and the output of the id command. | Enlarge the text in the xterm terminal window. | Hold Ctrl+Right-Click in the center of the xterm window to see text size options and select â€œHugeâ€. | . | Run the following commands: . | uname -a to show Debian kernel version. | id to show username and user groups. | . | Take a screenshot of the Debian screen. You can use VirtualBoxâ€™s built-in option View -> Take Screenshot, or your host OS screenshot tools. An example can be seen in Figure FigureÂ 3. FigureÂ 3: Debian Deliverable Example | Once you have a screenshot, you can shut down Debian and delete the ISO installation image. Congratulations on using debian! . | . ",
    "url": "/assignments/pa1.html#loc-38",
    
    "relUrl": "/assignments/pa1.html#loc-38"
  },"28": {
    "doc": "Programming Assignment 1",
    "title": "9 - Submission",
    "content": "On Gradescope, submit a PDF file that contains: . | The Stevens Honor Pledge | The 3 screenshots you created, one for OpenBSD, one for Arch, and one for Debian. Each screenshot should clearly show your login name, and the command output. | . ",
    "url": "/assignments/pa1.html#loc-48",
    
    "relUrl": "/assignments/pa1.html#loc-48"
  },"29": {
    "doc": "Programming Assignment 1",
    "title": "Programming Assignment 1",
    "content": ". ",
    "url": "/assignments/pa1.html",
    
    "relUrl": "/assignments/pa1.html"
  },"30": {
    "doc": "Programming Assignment 2",
    "title": "1 - Introduction",
    "content": "The objective of this assignment is to familiarize yourself with the Linux kernel source code. Specifically, you will: . | Compile your own Linux kernel. | Create your own kernel module. | Add a new kernel system call and then test this system call from a user-space program. | . All the assignmentâ€™s steps must be performed using your Debian virtual machine from PA 1. The notions from the course involved in this assignment are the following: . | Linux source code exploration and compilation. | Installing and running a modified kernel, as well as creating and testing a module. | The printk kernel function. | User space/kernel space communication using a system call. | . Remember to read the instructions carefully before following them, as some actions are time-sensitive. ",
    "url": "/assignments/pa2.html",
    
    "relUrl": "/assignments/pa2.html"
  },"31": {
    "doc": "Programming Assignment 2",
    "title": "2 - Find and Boot Your â€œKnown Goodâ€ Kernel",
    "content": "Start the Debian VM, log in, open a terminal window. Execute the following command to find the exact version of the kernel you are currently running: uname -r . Write down the result somewhere and remember this exact kernel version for the rest of the semester. This is your â€œknown goodâ€ kernel which is known to work correctly. Also execute ls -l /boot and you should see one â€œvmlinuzâ€ file in the /boot directory that has the exact same version in its name. This is the file containing your â€œknown goodâ€ kernel. Never delete or modify this file in any way. Use Debianâ€™s battery icon menu (upper right corner of the Debian desktop) to restart the virtual machine. As soon as you see the white-on-blue-green menu of the GRUB boot loader, press the down arrow key on the keyboard to select the second menu entry named â€œAdvanced options for Debian GNU/Linuxâ€. You have only 5 seconds to do this! Then press Enter to get a sub-menu. In the sub-menu, select the â€œknown goodâ€ kernel, based on the version you learned just above (but not the â€œrecovery modeâ€ one, which is similar to Microsoft Windowsâ€™s â€œsafe modeâ€, which is not what we want here) and press Enter to boot this â€˜known goodâ€œ kernel. From now on this is what you will do every time you boot or reboot the VM, to make sure you always know exactly which kernel you are booting! If later you have a problem when testing your own modified â€œworkingâ€ kernel (see below), such as a kernel that panics (crashes) on boot, you will always be able to boot this â€œknown goodâ€ kernel instead to get back to work. ",
    "url": "/assignments/pa2.html",
    
    "relUrl": "/assignments/pa2.html"
  },"32": {
    "doc": "Programming Assignment 2",
    "title": "3 - Build Your â€œWorkingâ€ Kernel",
    "content": "3.1 - Prerequisites . | Before compiling your own â€œworkingâ€ kernel, you must first install some tools and the Linux kernel source code. So, after booting the â€œknown goodâ€ kernel (as indicated above), log in, open a terminal window, and execute the following command to install all the software required to configure and compile the Linux kernel source code: . sudo apt install build-essential pahole libelf-dev libncurses-dev libssl-dev flex bison . | build-essential is a software package that depends on all the development libraries and header files and basic development tools that you need, so installing it guarantees that all those things are present on your VM. | pahole and libelf-dev are a set of tools and a library to handle Executable and Linkable Format (ELF) files. | libncurses-dev is a library to create text-based user interfaces, which is used by make menuconfig below. | libssl-dev is a library that provides cryptographic functions and secure networking. | flex is a lexer/scanner generator. | bison is a parser generator. | . | Install the Linux kernel source code: . | Execute sudo apt install linux-source&#x20; This automatically selects the right version of the Linux kernel source code, based on the version of the â€œknown goodâ€ kernel which is currently executing on your VM. | Execute ls -l /usr/src and you should see one file named linux-source-X.Y.tar.xz. tar is the standard file archive format for Unix, and xz is one among many compressed file formats on Unix (other common ones are gz and bz2). Together, tar and xz give you a compressed file archive, similar in spirit to the zip compressed file archive format which is used a lot on Microsoft Windows. | Execute cd ~ to make sure that you are in your home directory. | Decompress and extract the kernel source code you just installed: . tar -xavf /usr/src/linux-source-X.Y.tar.xz . | -x means â€œextractâ€. | -a means â€œauto-compressâ€ or â€œauto-decompressâ€ depending on context. | -v means â€œverboseâ€, to see the names of the extracted files as the extraction happens | -f specifies the name of the compressed archive file. | . After doing this, you should have in your home directory a new directory named linux-source-X.Y. Use ls to see it. | Use du -s -h linux-source-X.Y to see how big the Linux kernel source code is. | Change the name of this new linux-source-X.Y directory: . mvlinux-source-X.Y pa2 . | Execute cd pa2 to move into the top directory of your Linux kernel source code. Use ls to have a look at the different directories there. | . | . 3.2 - Build Configuration . | Create the configuration file for the kernel: . | For simplicity, we will copy then modify the configuration file for the â€œknown goodâ€ kernel which is currently executing on your VM: . cp /boot/config-$(uname -r) .config . Again, the command uname -r tells you exactly which kernel version you are currently executing on the VM, so we can use the result of this command to copy the right kernel configuration file from the /boot directory into the current directory containing your Linux kernel source code. | Execute make menuconfig to modify this configuration file. You should then get a text-based user interface which allows you to easily modify your kernel configuration file. | Press Enter to go into the â€œGeneral setupâ€ sub-menu, press the down arrow twice on your keyboard to go down two lines, then Enter to select â€œLocal version - append to kernel releaseâ€. In the new text window that appears, enter a minus sign - followed by your login name (which is also your Stevens login name), followed by -pa2. For example: -rtsang1-pa2 (replace my login name with yours, obviously). Do not add any space before, inside, or after this text. This piece of text is going to be added to the version of the Linux kernel you are going to compile, so that later you can easily recognize which kernel is yours. This will be your â€œworkingâ€ kernel. Press Enter to select â€œOKâ€ and you should be back in the previous sub-menu, with the text you just typed is now showing between () parentheses in front of the name of the â€œLocal version - append to kernel releaseâ€ sub-menu. Press the right arrow on your keyboard to select â€œExitâ€ and then Enter to go back to the previous top-level menu. | Select Save and press Enter. In the new window, check that the default â€œ.configâ€ file name is correct and press Enter to save your new configuration file. Then select â€œExitâ€ to quit the â€œmenuconfigâ€ user interface and go back to the usual Unix shell. | Double check the differences between the original kernel configuration file and the one you just modified: . diff /boot/config-$(uname -r) .config . In the output you should see that the kernel variable CONFIG_LOCALVERSION is now defined to be the piece of text -rtsang1-pa2 (except with your own login name) while before it was the empty string (ignore any change for CONFIG_CC_VERSION_TEXT and for SALT, SIG, and KEY stuff, these changes are irrelevant). You are now ready to compile the Linux kernel source code for your â€œworkingâ€ kernel! . | . | . 3.3 - Compilation . | Execute nproc to see how many processors your VM is using (this should be the same number you indicated in the settings of the VM in VirtualBox or UTM). | You might also want to go into the settings of your host operating system (Microsoft Windows or Apple macOS) and make sure that the power settings of your computer are set for maximum performance (for example, in Microsoft Windows, click on the battery icon at the right end of the bottom taskbar, then move the slider to â€œBest performanceâ€); you can undo this setting later again after you are finished compiling the kernel. | Also make sure that your host OS is not set up to automatically suspend or shut down your host computer if you do not move the mouse or whatnot for a while. Again you can undo this later when you are finished compiling the kernel. | If you are using a laptop computer, also make sure that it is plugged into an electric socket, otherwise your host OS might automatically throttle your computerâ€™s performance to save the battery. | Ensure that Debian does not suspend itself while you are in the middle of compiling your kernel. Click with your right mouse button on the Debian desktop background, select â€œSettingsâ€, then â€œPowerâ€, then click on â€œAutomatic suspendâ€ and turn off both â€œOn Battery Powerâ€ and â€œPlugged Inâ€. | . | Now we are ready to compile the whole Linux kernel source code using all the VMâ€™s processors in parallel, to speed up things: . make -j $(nproc) all . Wait an hour or two (or more). You will know the compilation is over when your computerâ€™s fan stops making more noise than usualâ€¦ If for some reason you need to stop the compilation before it is finished, just press Ctrl-c on the keyboard. You can then re-start the compilation later using the same command again, and it will automatically restart from where it left off. If for some reason the compilation fails, it might be hard to see why it failed because you are compiling different parts of the kernel code in parallel. In that case, you can execute just make all to restart the compilation from where it failed but this time in sequential mode on a single CPU, which will make it much easier to see what the problem is. Then contact your nearest Course Assistant. If you look at the output of the make command while it is compiling the code, you will see different abbreviations: . | CC is when compiling a C file to get a .o object file (a file containing binary CPU instructions) | LD is when linking (gluing) multiple object files together | AR is when creating a library (a .a archive file of object files, which later will be linked with the rest of the kernel) | [M] means that this code is part of a dynamically loadable kernel module, not part of the monolithic Linux kernel proper. | . | Execute du -s -h . to see how much disk space the current directory containing the whole compiled Linux source code takes (it should be around 23 GB). | . 3.4 - Install and Boot . | When compiling the kernel, all the kernel modules are also compiled at the same time. We now need to install these new kernel modules: sudo make INSTALL_MOD_STRIP=1 modules_install . This can take a little while, and must be done as root (the system administrator) hence the use of sudo here. The INSTALL_MOD_STRIP=1 argument given to the make command tells make to strip extra debugging information from the modules when installing them, which saves around 2GB of disk space. | Once the modules are installed, you can execute ls -l /usr/lib/modules and you should see in the output a directory with a name that has your login name and pa2 at the end, which is where the modules were installed. The command du -s -h /usr/lib/modules/* should show you that all the different directories there (the one for your own modules, as well as the one for the â€œknown goodâ€ kernel) are about 400MB in size. | Now we can install the new â€œworkingâ€ kernel itself: . sudo make install . Do not worry about any â€œPlease install the Linux kernel â€œheaderâ€ files matching the current kernelâ€ message in the commandâ€™s output; we would need this only if we were to try to use our Debian VM as the host for another VM on top of it! . | Execute ls -l /boot and you will see that make installed several files there, all of which have your login name and â€œpa2â€ at the end of their name: . | config-X.Yâ€¦-rtsang1-pa2: a copy of the .config file you used for compiling your kernel (you can check this using the diff command, for example; see above) . | initrd.img-X.Yâ€¦-rtsang1-pa2: the kernelâ€™s â€œinitial RAM diskâ€ which the kernel only uses at boot time (see here for more information if you are curious) . | System.map-X.Yâ€¦-rtsang1-pa2: a list of your kernelâ€™s symbols (the function names and variable names inside the kernel) . | vmlinuz-X.Yâ€¦-rtsang1-pa2: your very own â€œworkingâ€ kernel! . | . As part of the kernelâ€™s installation, the configuration file for the GRUB bootloader is also automatically updated so that the bootloader now knows about your new kernel. | READ FIRST: Use Debianâ€™s battery icon menu to restart the virtual machine. As soon as you see the white-on-blue-green menu of the GRUB boot loader, press the down arrow key on the keyboard to select the second menu entry named â€œAdvanced options for Debian GNU/Linuxâ€. You have only 5 seconds to do this! Then press Enter to get a sub-menu. In the sub-menu, select now your own â€œworkingâ€ kernel, which has your login name and â€œpa2â€ at the end of its name (but again not the â€œrecovery modeâ€ one) and press Enter to boot your own kernel. Happiness ensues. | . 3.5 - Deliverables . | After booting your own â€œworkingâ€ kernel, log in, open a terminal window, use Ctrl-+ to increase the font size of the terminal window, and execute uname -a (which should show a kernel name with your own login name and â€œpa2â€ at the end of it) and then id. Take a screenshot and save it as a picture somewhere on your host computer, you will need to submit it later on Canvas (more details about this at the end of this document). Make sure the kernel version and your login name (Stevens login name) are clearly visible inside the terminal window in your screenshot. For example: . | . Congratulations on compiling and booting your first Linux kernel! . Now create in your home directory another new directory that you will use for submitting your assignment (again, use your own Stevens login name): . cd; mkdir rtsang1-pa2 . Then copy your â€œworkingâ€ kernel configuration file into your submission directory: . cp pa2/.config rtsang1-pa2 . 3.6 - Backup . To finish this part of the assignment, create a backup copy of the kernel source code you just compiled, just in case. There are 2 options: . | (Long) Do a recursive copy: cp -p -r pa2 pa2-backup . | -r means to do a recursive copy that will automatically copy the directory and all of its subdirectories | -p preserves the file timestamps when copying. GNU Make uses timestamps to determine if a file needs to be recompiled, and preserving the timestamp will prevent it from being recompiled unnecessarily. | . | (Longer) Create a compressed archive: tar -cJvf pa2-backup.tar.xz pa2/ . | . The recursive copy is slightly faster, but will take up more disk space on the VM (23 GB at time of writing). Using tar will take longer due to compression, but will take up much less space (2.9 GB at time of writing). Later, when doing the rest of this assignment, if you make a big mistake inside your â€œpa2â€ directory, such as accidentally deleting some files, you can restore them from your backup. (tar can extract single files from an archived directory) . In the worst case, if you do not know how to fix the mistake, you can always completely delete your â€œpa2â€ directory (cd ~; rm -rf pa2) and re-create it using the backup copy (cp -p -r pa2-backup pa2 or tar -xJvf pa2-backup.tar.xz). ",
    "url": "/assignments/pa2.html#build-your-working-kernel",
    
    "relUrl": "/assignments/pa2.html#build-your-working-kernel"
  },"33": {
    "doc": "Programming Assignment 2",
    "title": "4 - Custom Kernel Module",
    "content": ". | In your submission directory (cd rtsang1-pa2), create a new directory (mkdir module). In that new directory (cd module), write a Linux kernel module in a file named LOGIN.c (like rtsang1.c but use your own login name). | This module must have a printk() statement that outputs â€œHello World from NAME (LOGIN)â€ in the kernel log when the module is loaded into the kernel, where NAME is your full legal name and LOGIN is your Stevens login name. | When the kernel module is unloaded it must print â€œPID is XYZ and program name is NAMEâ€ where XYZ is the PID number and NAME is the program name of the current process. Linux stores process information in structures called â€œtasksâ€ (defined here). You can use the current macro in asm-generic/current.h to access the task struct for the current process. | . | Compile your kernel module using the appropriate Makefile. (Make sure that you are still running your own â€œworkingâ€ kernel when doing this!) . | . 4.1 - Deliverables . | You must provide a single screenshot that shows two Debian terminal windows side by side: . | One window must show the kernel log (with your moduleâ€™s output visible in it) | The other window must show the output of the uname -a command followed by commands to load-unload your module at least twice (so we can see in the kernel log that the PID printed when unloading the module changes during each unload). | . | Save the screenshot somewhere on your host computer, you will need to submit it later on Canvas (more details about this at the end of this document). For example (partly censored): . | . ",
    "url": "/assignments/pa2.html#custom-kernel-module",
    
    "relUrl": "/assignments/pa2.html#custom-kernel-module"
  },"34": {
    "doc": "Programming Assignment 2",
    "title": "5 - Custom System Call",
    "content": "5.1 - Adding The System Call . | In the directory containing the compiled source code of your â€œworkingâ€ kernel create a new directory. cd ~/pa2 # `~` is your home directorymkdir my_syscall . | In that new directory, in a file named my_syscall.c, write the C code for a new system call named LOGIN_syscall (replace LOGIN with your Stevens login name) that takes as single parameter a pointer to a character array containing a string. Make sure you use the proper C macro to define your system call (see linux/syscalls.h and the gettimeofday syscall for an example). The code of your system call must always return a signed long integer (long) as result. Your system call should do the following: . | If the string pointer given as argument is NULL then your system call must immediately return -1. | If the string length is larger than 32 (where the string length is its total number of characters, including the \\0 string terminator character), then your system call must immediately return -1. | Copy the string from user space to kernel space. | Use printk to print â€œbefore: â€œ followed by the string. Note: whenever you use printk, always make sure that the string you want to print is terminated with a \\n newline character, otherwise the string will not immediately appear in the kernel logs when your code is executed. | Replace all occurrences of a lowercase vowel letter (a, e, i, o, u) in the string with the first letter of your login name, in uppercase (for example, given my rtsang1 login name, the letters a, e, i, o, and u are all replaced with the uppercase letter R). | Use printk to print after:&#x20; followed by the modified string. | Copy the modified string from kernel space to user space. | The system call then returns as result the number of character replacements performed in step 5. | . In your code, make use of the following kernel functions from include/linux/uaccess.h and as much as possible: . | Function | Description | . | get_user | gets a simple variable from user space | . | put_user | puts a simple variable to user space | . | clear_user | clears, or zeros, a block in user space | . | copy_to_user | copies a block of data from the kernel to user space | . | copy_from_user | copies a block of data from the user space to the kernel | . | strnlen_user | gets the size of a string buffer in user space | . | strncpy_from_user | copies a string from user space into the kernel | . IBM has archived documentation that may prove useful. If any of the above functions fail, return -EFAULT. Make sure your code properly checks for errors when using each of these functions (refer to the syscalls used in https://elixir.bootlin.com/linux/latest/source/kernel/time/time.c#L140). Do not use a module to implement your system call. | Modify other files in the Linux kernel source code as necessary: . | arch/x86/entry/syscalls/syscall_64.tbl: Add your syscall to the syscall table. (Use tabs, not spaces between fields) . | include/linux/syscalls.h: Add your syscall prototype to the header file. | my_syscall/Makefile: Add your syscall to the build system. This file should only contain: . obj-y += my_syscall.o . | Makefile: Update the build system to build your syscall. Make the following modification: . core-y := my_syscall/ . | . | Give your system call the the last number in the syscall table +1 (463 at time of writing). | Keep a list somewhere of all the files you modify, because later you will need to copy them to your submission directory. | . | Recompile your â€œworkingâ€ kernel, the same way you did it in SectionÂ 3.3. Some of the files you need to modify are referenced throughout the kernelâ€™s code, so, when recompiling, the make command then needs to recompile most of the kernel code again, which again takes a very long time. So make sure you modify the files correctly on the first try, so you do not have to recompile the whole kernel over and over. If you only need to change your my_syscall/my_syscall.c file then recompiling the kernel should take only about 5 minutes since the rest of the kernelâ€™s code will not need to be recompiled again in this case. | Reinstall your â€œworkingâ€ kernel and its associated modules if and only if compilation succeeded. See SectionÂ 3.4. When installing your modified â€œworkingâ€ kernel, the previous version of your â€œworkingâ€ kernel will be renamed with an extra â€œ.oldâ€ extension at the end of its name. You can just ignore this one. | Reboot the virtual machine and make sure that you use the GRUB bootloader to select the correct kernel when rebooting (your â€œworkingâ€ kernel with the â€œ-rtsang1-pa2â€ name, that now contains the code for your own system call). | If your â€œworkingâ€ kernel panics (crashes) on boot for some reason, reboot the VM using your â€œknown goodâ€ kernel and fix the problem in the code of your â€œworkingâ€ kernel. | . | After you have booted the correct kernel, do the following to double-check that the kernel you are now running actually knows about your system call: . | Ensure your syscall symbol is in the System.map: . grep rtsang1_syscall /boot/System.map-*-pa2 . (using your login instead of mine of course) . You should get a dozen different names related to your system call in the output of the command. | Ensure your syscall symbol is in /proc/kallsyms: . grep rtsang1_syscall /proc/kallsyms . You should see the same output as above. | . If the output the above commands is empty, then the kernel that you are currently running does not know about your system call, which means that either you booted the wrong kernel or you did something wrong somewhere. Re-read this whole section and try again. | . 5.2 - Testing The System Call . In your submission directory (cd ~/rtsang1-pa2), write the C code for a user-space test program called syscall.c that invokes your system call. Since your system call does not have a corresponding C wrapper function available in the C standard library, you must directly use the syscall function of the C standard library to call your system call (see OS concepts lecture notes for an example). Your code must invoke your system call twice: . | once for the case where the string size is larger than 32. | once for the case where the string size is less than 32. | . In both cases, your C program must print on the screen: . | The string given to the syscall, before the system call happens. | The return value of the syscall. | The string after the system call, even if it has not been modified. | . You can directly use the system call number 463 in your C code. The strings that you use in your code must be defined as local variables (the same way it is done for example on slide 19 of the â€œOS Concepts and Structureâ€ lecture notes), not as string constants that you directly give to the system call as argument. This is because, when your code executes inside a process, all the string constants from your code are stored in a part of the â€œdataâ€ segment of the processâ€™s address space which is read-only (since string constants areâ€¦ constant), which in turn means that your kernel system call would fail when trying to modify those strings. Local variables are stored in the processâ€™s stack, which is read-write and your system call will then be able to modify those strings. 5.3 - Deliverables . You must provide a single screenshot that shows two Debian terminal windows side by side: . | one window must show the kernel log (with your system callâ€™s output visible in it, when the string given as argument to the system call is short enough) | the other window must show the output of the uname -a command followed by the execution of your user-space test program. | . Save the screenshot somewhere on your host computer, you will need to submit it later on Gradescope (more details about this below). For example: . ",
    "url": "/assignments/pa2.html#custom-system-call",
    
    "relUrl": "/assignments/pa2.html#custom-system-call"
  },"35": {
    "doc": "Programming Assignment 2",
    "title": "6 - Submission",
    "content": ". | Once both your system call and your user-space test program work, copy the code of the system call, plus any other kernel file you modified, into your submission directory (your user-space test program must already be there): | . cd ~/pa2; cp -p -r my_syscall &lt;any other file you modified> ~/rtsang1-pa2 . | In your submission directory, create a file named login.txt that contains your Stevens login ID: . cd ~/rtsang1-pa2echo \"rtsang1\" > login.txt . The autograder uses this to confirm you have submitted all necessary files. You must include this file or you will fail the autograder! . | In your submission directory, create a PDF file named screenshots.pdf that contains: . | Your full name. | The Stevens Honor pledge. | The three screenshots you created above: . | one showing that you compiled your own â€œworkingâ€ kernel (SectionÂ 3) | one showing how your kernel module works (SectionÂ 4) | one showing how your system call and your user-space test program work (SectionÂ 5) | . Make sure the screenshots are clearly readable. Also add a short explanation before each screenshot so the Course Assistants know what you are trying to show on those screenshots. | . At this point the submission directory (rtsang1-pa2) must contain all the files you have created or modified during this assignment (including the kernel .config configuration file, which you can only see in the submission directory by using the ls -a command). If you install the tree utility program and run the command tree -a rtsang1-pa2, you should see the following structure: . rtsang1-pa2â”œâ”€â”€ .configâ”œâ”€â”€ login.txtâ”œâ”€â”€ moduleâ”‚Â Â  â”œâ”€â”€ Makefileâ”‚Â Â  â””â”€â”€ rtsang1.câ”œâ”€â”€ my_syscallâ”‚Â Â  â”œâ”€â”€ Makefileâ”‚Â Â  â””â”€â”€ my_syscall.câ”œâ”€â”€ &lt;other files>â””â”€â”€ syscall.c . | Install the zip program on your virtual machine (sudo apt install zip) and then create a ZIP file of your submission directory: . cd; zip -r rtsang1-pa2.zip rtsang1-pa2 . The -r flag means to zip all the subdirectories recursively: do not forget it! . Remember to use your own login name instead of mine. | Once you have correctly created the file rtsang1-pa2.zip, copy it to the host OS using your shared folder, double-check its content to make sure it contains everything (see SectionÂ 7). | Submit your submission zip file on Gradescope and confirm autograder sanity checks pass. Solutions will be graded manually. Autograder tests are not exhaustive. | . After the deadline for this assignment has passed, you can delete the backup copy of your â€œworkingâ€ kernel: rm -rf ~/pa2-backup . It is up to you whether you delete the compiled source code of your â€œworkingâ€ kernel or not (rm -rf ~/pa2), you will not need it anymore this semester. You can delete it after the deadline for this assignment has passed, if you want to save VM disk space, or delete it only at the end of the semester, or keep it for ever as a souvenir! . ",
    "url": "/assignments/pa2.html",
    
    "relUrl": "/assignments/pa2.html"
  },"36": {
    "doc": "Programming Assignment 2",
    "title": "7 - Rubric",
    "content": "| Percentage | Item | . | 5% | Correct .config file | . | 5% | Screenshot showing the corresponding â€œworkingâ€ kernel version | . | 15% | Code of module/rtsang1.c (with your login name) | . | 5% | Code of module/Makefile | . | 10% | Screenshot of kernel log with module loading-unloading (twice) | . | 25% | Code of my_syscall/my_syscall.c | . | 5% | Code of my_syscall/Makefile | . | 15% | Code of syscall.c | . | 5% | Other modified kernel files | . | 10% | Screenshot of kernel log and output of syscall.c | . You do not get points for screenshots unless the corresponding files are submitted too. So for example you will not get points for the first screenshot listed above if you do not also provide the corresponding .config file. Screenshots alone will not get you any points at all, so make sure you double check everything before you submit on Gradescope! . ",
    "url": "/assignments/pa2.html#rubric",
    
    "relUrl": "/assignments/pa2.html#rubric"
  },"37": {
    "doc": "Programming Assignment 2",
    "title": "Programming Assignment 2",
    "content": ". ",
    "url": "/assignments/pa2.html",
    
    "relUrl": "/assignments/pa2.html"
  },"38": {
    "doc": "Syllabus",
    "title": "Contents",
    "content": ". | Course Info | Course Description | Student Learning Outcomes | Course Topics | Grade Breakdown | Course Policies . | Programming Assignments . | Assignment Late Policy | . | Exams and Quizzes | Regrade Requests | . | Academic Integrity . | Generative AI | Undergraduate Honor System | . | Accomodations . | Disability Services Confidentiality Policy | . | Inclusivity | Mental Health Resources | Emergency Information | . ",
    "url": "/syllabus.html",
    
    "relUrl": "/syllabus.html"
  },"39": {
    "doc": "Syllabus",
    "title": "Course Info",
    "content": "| Instructor | Ryan Tsang | . | Contact | rtsang1@stevens.edu | . | Office | GS 247 | . | Office Hours | TBD | . | Prereqs | CS 392 | . | Course Assistants | | Name | Email | OH | . | Aya Salama | asalama@stevens.edu | W 4:00pm - 6:00pm GS 226 | . | Nicole Young | nyoung2@stevens.edu | TBD | . | Brayden Abo | babo@stevens.edu | T 12:00pm - 2:00pm GS 226 | . | . | Links | . | Canvas, | Gradescope, | Discord | . | . | Materials | . | Tanenbaum and Bos. Modern Operating Systems. 5th Edition. | Corbet, Rubini, and Kroah-Hartman. Linux Device Drivers. 3rd Edition. [Online] | (Optional) Bovet and Cesati. Understanding the Linux Kernel. 3rd Edition. [Online] | Additional material will be posted on Canvas as needed | . | . ",
    "url": "/syllabus.html#loc-1",
    
    "relUrl": "/syllabus.html#loc-1"
  },"40": {
    "doc": "Syllabus",
    "title": "Course Description",
    "content": "The use and internals of modern operating systems. Lectures focus on internals whereas programming assignments focus on use of the operating system interface. Major topics include: . | Processes | Concurrency and Multithreading | Memory Management | Virtual Memory | Shared Libraries | File System Data Structures | Input/Output | . ",
    "url": "/syllabus.html#loc-2",
    
    "relUrl": "/syllabus.html#loc-2"
  },"41": {
    "doc": "Syllabus",
    "title": "Student Learning Outcomes",
    "content": ". | I am able to explain how preemptively scheduled processes and threads provide an abstraction that a program is the only one executing. | I am able to explain how virtual memory provies an abstraction of physical memory. | I am able to explain how an operating systemâ€™s input/output architecture provides an abstraction that every data source or sink behaves identically. | I am able to explain how the data structures of the UNIX file system serve to map file names to blocks of a storage device. | I am able to explain in detail how a system call is made and returns. | I am able to write a multi-threaded C program that uses at least one classical synchronization mechanism to solve at least one classical synchronization problem. | . ",
    "url": "/syllabus.html#loc-3",
    
    "relUrl": "/syllabus.html#loc-3"
  },"42": {
    "doc": "Syllabus",
    "title": "Course Topics",
    "content": "| Topic | Reading | . | Introduction | MOS 1, 10.2; LDD 1 | . | Introduction to Linux | MOS 1.6, 10.2; LDD 1 | . | Processes and Threads | MOS 2.1 - 2.2, 6.1 | . | Scheduling | MOS 2.4 | . | Concurrency | MOS 2.3, 2.5 | . | Memory Management | MOS 3.1 - 3.2 | . | Virtual Memory | MOS 3.3 - 3.5, 3.7 | . | File Systems | MOS 4.1 - 4.3 | . | Input/Output | MOS 4.4, 5.1 - 5.4 | . ",
    "url": "/syllabus.html#loc-4",
    
    "relUrl": "/syllabus.html#loc-4"
  },"43": {
    "doc": "Syllabus",
    "title": "Grade Breakdown",
    "content": "| Category | Percentage | . | Quizzes | 10% | . | Programming Assignments | 30% | . | Group Project | 20% | . | Midterm Exam | 20% | . | Final Exam | 20% | . Letter grades will be assigned by bins tentatively as follows: . | Grade | Threshold | . | A | â‰¥ 92.5% | . | A- | â‰¥ 90.0% | . | B+ | â‰¥ 87.5% | . | B | â‰¥ 82.5% | . | B- | â‰¥ 80.0% | . | C+ | â‰¥ 77.5% | . | C | â‰¥ 72.5% | . | C- | â‰¥ 70.0% | . | D+ | â‰¥ 67.5% | . | D | â‰¥ 60.0% | . | F | &lt; 60.0% | . Grade bins may be adjusted at the end of the semester. ",
    "url": "/syllabus.html#loc-5",
    
    "relUrl": "/syllabus.html#loc-5"
  },"44": {
    "doc": "Syllabus",
    "title": "Course Policies",
    "content": "You, your instructor, and the course assistants are bound by the Stevens Honor System. Honor System violations will always be reported to the Honor Board without exception. Students are responsible for being aware of policies made via: . | this syllabus | in-class | discord | email | . Programming Assignments . | Programming Assignments must be completed individually and the vast majority of your work should be original. You are encouraged to discuss the problems with your classmates but you must not share implementation details. If you are unsure whether you have shared too much, discuss the situation with the instructor before submitting. | If at any point you use even a small part of an external source, whether this is an online resource, another studentâ€™s code, or an LLM-generated example, you MUST cite the source. Copying from from an external source without citation will result in, at minimum, an automatic zero for the assignment. | We will use anti-plagiarism tools on assignments to verifiy similarity of solutions. If tools indicate a high likelihood of plagiarism, it will be treated as a violation of the Stevens Honor System. | Attempting to fake/hard-code results in any portion of a programming assignment will result in a zero on the entirety of the assignment. | . Assignment Late Policy . Note: this policy applies only to programming assignments. | You have 3 total slip days to use throughout the semester for homework extensions. Slip days are applied automatically. Do not email the instructor to use them. | Following any slip days used, there will be a 20% penalty for each additional day late. The last day to submit an assignment for a maximum 50% penalty will be explicitly stated on the the assignment instructions. | There is a 10 minute grace period for assignment submissions before slip days or penalties are applied. | . Exams and Quizzes . Exams and quizzes are conducted in-person. All accomodation requests must be registered with the Office of Disability Services at least 1 week before the relevant accomodation would apply. | You may not use any electronic devices during exams or quizzes. This includes, but is not limited to: . | Laptops | Cell Phones | Tablets | Smart Watches | Smart Glasses | . | You may not work with or talk to other students during exams. | You may use one, double-sided, 8.5 x 11 page of handwritten notes on exams only. No other materials are permitted. Using notes that are not handwritten or larger than the indicated size will result in a penalty on the final exam score. | . Regrade Requests . | Students have 3 days after grades are posted to inform your grader and the instructor of a problem. Regrade requests submitted after 3 days have passed will be ignored. | . ",
    "url": "/syllabus.html#loc-6",
    
    "relUrl": "/syllabus.html#loc-6"
  },"45": {
    "doc": "Syllabus",
    "title": "Academic Integrity",
    "content": "Generative AI . You may use generative AI technology, e.g. Chat-GPT, with care to generate ideas and brainstorm. However, you should note that the material generated by these programs may be inaccurate, incomplete, or otherwise problematic. You may treat these programs like a virtual fellow student: you are allowed to â€œdiscussâ€ with them at a conceptual level (though be aware that the information they provide may be inaccurate), but you cannot share solutions or code in either direction. Presenting AI-generated work as your own is plagiarism. If you include material generated by an AI program, it should be cited like any other reference material and clearly attributed. Any plagiarism or other form of cheating will be dealt with under relevant Stevens policies. Undergraduate Honor System . Enrollment into the undergraduate class of Stevens Institute of Technology signifies a studentâ€™s commitment to the Honor System. Accordingly, the provisions of the Stevens Honor System apply to all undergraduate students in coursework and Honor Board proceedings. It is the responsibility of each student to become acquainted with and to uphold the ideals set forth in the Honor System Constitution. More information about the Honor System including the constitution, bylaws, investigative procedures, and the penalty matrix can be found online. The following pledge shall be written in full and signed by every student on all submitted work (including, but not limited to, homework, projects, lab reports, code, quizzes and exams) that is assigned by the course instructor. No work shall be graded unless the pledge is written in full and signed. â€œI pledge my honor that I have abided by the Stevens Honor System.â€ Reporting Honor System Violations. Students who believe a violation of the Honor System has been committed should report it within ten business days of the suspected violation. Students have the option to remain anonymous and can report violations online. ",
    "url": "/syllabus.html#loc-11",
    
    "relUrl": "/syllabus.html#loc-11"
  },"46": {
    "doc": "Syllabus",
    "title": "Accomodations",
    "content": "Stevens Institute of Technology is dedicated to providing appropriate accommodations to students with documented disabilities. The Office of Disability Services (ODS) works with undergraduate and graduate students with learning disabilities, attention deficit-hyperactivity disorders, physical disabilities, sensory impairments, psychiatric disorders, and other disabilities to help students achieve their academic and personal potential. They facilitate equitable access to the educational programs and opportunities offered at Stevens and coordinate reasonable accommodations for eligible students. These services are designed to encourage independence and self-advocacy with support from the ODS staff. The ODS staff will facilitate the provision of accommodations on a case-by-case basis. For more information about Disability Services and the process to receive accommodations, visit their website. If you have any other questions, please contact the Office of Disability Services at disabilityservices@stevens.edu or by phone at 201.216.3748. Disability Services Confidentiality Policy . Student Disability Files are kept separate from academic files and are stored in a secure location within the Office of Disability Services. The Family Educational Rights Privacy Act (FERPA, 20 U.S.C. 1232g; 34CFR, Part 99) regulates disclosure of disability documentation and records maintained by Stevens Disability Services. According to this act, prior written consent by the student is required before our Disability Services office may release disability documentation or records to anyone. An exception is made in unusual circumstances, such as the case of health and safety emergencies. ",
    "url": "/syllabus.html#loc-14",
    
    "relUrl": "/syllabus.html#loc-14"
  },"47": {
    "doc": "Syllabus",
    "title": "Inclusivity",
    "content": "Stevens Institute of Technology believes that diversity and inclusiveness are essential to excellence in academic discourse and innovation. In this class, the perspective of people of all races, ethnicities, gender expressions and gender identities, religions, sexual orientations, disabilities, socioeconomic backgrounds, and nationalities will be respected and viewed as a resource and benefit throughout the semester. Suggestions to further diversify class materials and assignments are encouraged. If any course meetings conflict with your religious events, please do not hesitate to reach out to your instructor to make alternative arrangements. You are expected to treat your instructor and all other participants in the course with courtesy and respect. Disrespectful conduct and harassing statements will not be tolerated and may result in disciplinary actions. Name and Pronoun Usage. As this course includes group work and class discussion, it is vitally important for us to create an educational environment of inclusion and mutual respect. This includes the ability for all students to have their chosen gender pronoun(s) and chosen name affirmed. If the class roster does not align with your pronouns and/or name, please inform the instructor of the necessary changes. Religious Holidays. Stevens is a diverse community that is committed to providing equitable educational opportunities and supporting students of all ethnicities and belief systems. Religious observance is an essential reflection of that rich diversity. Students will not be subject to any grade penalties for missing a class, examination, or any other course requirement due to religious observance. In addition, students will not be asked to choose between religious observance and academic work. Therefore, students should inform the instructor at the beginning of the semester if a requirement for this course conflicts with religious observance so that accommodations can be made for students to observe religious practices and complete the requirements for the course. ",
    "url": "/syllabus.html#loc-16",
    
    "relUrl": "/syllabus.html#loc-16"
  },"48": {
    "doc": "Syllabus",
    "title": "Mental Health Resources",
    "content": "Part of being successful in the classroom involves a focus on your whole self, including your mental health. While you are at Stevens, there are many resources to promote and support mental health. The Office of Counseling and Psychological Services (CAPS) offers free and confidential services to all enrolled students who are struggling to cope with personal issues (e.g., difficulty adjusting to college or trouble managing stress) or psychological difficulties (e.g., anxiety and depression). Appointments can be made by phone (201-216-5177), online, or in person on the 2nd Floor of the Student Wellness Center. ",
    "url": "/syllabus.html#loc-17",
    
    "relUrl": "/syllabus.html#loc-17"
  },"49": {
    "doc": "Syllabus",
    "title": "Emergency Information",
    "content": "In the event of an urgent or emergent concern about your own safety or the safety of someone else in the Stevens community, please immediately call the Stevens Campus Police at 201-216-5105 or on their emergency line at 201-216-3911. These phone lines are staffed 24/7, year-round. For students who do not reside near the campus and require emergency support, please contact your local emergency response providers at 911 or via your local police precinct. Other 24/7 national resources for students dealing with mental health crises include the National Suicide Prevention Lifeline (1-800-273-8255) and the Crisis Text Line (text â€œHomeâ€ to 741-741). If you are concerned about the wellbeing of another Stevens student, and the matter is not urgent or time sensitive, please email the CARE Team at care@stevens.edu. A member of the CARE Team will respond to your concern as soon as possible. ",
    "url": "/syllabus.html#loc-18",
    
    "relUrl": "/syllabus.html#loc-18"
  },"50": {
    "doc": "Syllabus",
    "title": "Syllabus",
    "content": ". SyllabusCS 492 - Operating Systems . DISCLAIMER: This syllabus is a living document. While policies are unlikely to change dramatically, I reserve the right to change them if I deem it necessary to adapt to changing circumstances. ",
    "url": "/syllabus.html",
    
    "relUrl": "/syllabus.html"
  }
}
